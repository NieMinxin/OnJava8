# On Java 8 thinking
	目录
	-1.什么是对象
	-2.万物皆对象
	-3.运算符
	-4.初始化和清理
	-5.封装
	-6.继承和复用
	-7.多态
	-8.接口
	-9内部类
	-10.容器
	-11.函数式编程
	-12.流
	-13.异常
	-14.校验代码
	-15.文件
	-16.字符串
	-17.类型信息
	-18.泛型
	-19.数组
	-20.枚举
	-21.注解
	-22.多线程
	-23.设计模式
	
	

	
## 什么是对象
	>
	
	面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种表达非常具有普遍性，所以不	必受限于特定类型的问题。我们将问题空间中的元素以及它们在解决方案空间的表示称作“对象”（**Object**）。	
	
	我们可以理解纯粹的面向对象程序设计方法：
		-1.万物皆对象
		-2.**程序是一组对象，通过消息传递来告知彼此该做什么**
		-3.每个对象都有自己的存储空间，可容纳其他对象
		-4.**每个对象都有一种类型**
		-5.**同一类所有对象都能接收相同的消息**
	>
	
	聚合和组合
		>
		组合和聚合都属于关联关系的一种，只是额外具有整体-部分的意义。至于是聚合还是组合，需要根据实际的业务需求来判断。可能相同超类和子类，在不同的业务场景，关联关系会发生变化。只看代码是无法区分聚合和组合的，具体是哪一种关系，只能从语义级别来区分。聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。
		
			“组合”关系给我们的程序带来极大的灵活性。 一半会使用private 访问权限
		>
	$$"是一个"与"像是一个"的关系
	在子类继承父类时，如果子类没有扩展该类的元素，这就是一种is a关系，若子类扩展本类的元素虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。
	
	
	多态
		>
		可以通过通用的“形状”基类派生出新的“五角形”形状的子类，而不需要修改通用"形状"基类的方法。通过派生新的子类来扩展设计的这种能力是封装变化的基本方法之一。
		
		早期绑定：译器生成对特定函数名的调用，该调用会被解析为将执行的代码的绝对地址。
		后期绑定：当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码
		
		
				为了执行后期绑定，Java 使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址。
		
		>
	对象创建与生命周期
		栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间
		第二种方法是在堆内存（Heap）中动态地创建对象。
		在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。
		Java 使用动态内存分配。每次创建对象时，使用 `new` 关键字构建该对象的动态实例。这又带来另一个问题：对象的生命周期。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。
---------------------------------------------------------------------------------------------------------------------------------------

##万物皆对象
	
	对象的操作底层使用的是指针，但我们操作的标识符实际上是对象的引用， 举例：我们可以用遥控器（引用）去操纵电视（对象）。
	例如：
		String str;这就是一个string对象的引用，对象的引用而非对象，直接使用会出现错误，因为没有给对象赋值，也就是通常所说的指向对象，通常安全的做法是创建一个引用并且同时进行初始化。
	例如：	String str =“hello”
	也可以使用new关键字创建对象实例	String str = new String("hello");
	
	
	**数据存储**
		1.**寄存器**（Registers）最快的存储区域，位于 CPU 内部 
		2.**栈内存**（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java 系统必须准确地知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据，特别是对象引用，但!! Java 对象却是保存在堆内存的!!	
		3.**堆内存**（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。
		4.**常量存储**（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 [^3]。
		5.**非 RAM 存储**（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。
		
		$$java语言的基本数据类型内存占用的大小不会像其他语言一样随机器的变化而变化。
		

		| 基本类型 |  大小   |      最小值      |          最大值           | 包装类型  |
		| :------: | :-----: | :--------------: | :-----------------------: | :-------: |
		| boolean  |    —    |        —         |             —             |  Boolean  |
		|   char   | 16 bits |    Unicode 0     | Unicode 2<sup>16</sup> -1 | Character |
		|   byte   | 8 bits  |       -128       |           +127            |   Byte    |
		|  short   | 16 bits | - 2<sup>15</sup> |    + 2<sup>15</sup> -1    |   Short   |
		|   int    | 32 bits | - 2<sup>31</sup> |    + 2<sup>31</sup> -1    |  Integer  |
		|   long   | 64 bits | - 2<sup>63</sup> |    + 2<sup>63</sup> -1    |   Long    |
		|  float   | 32 bits |     IEEE754      |          IEEE754          |   Float   |
		|  double  | 64 bits |     IEEE754      |          IEEE754          |  Double   |
		|   void   |    —    |        —         |             —             |   Void    |
	
	
		高精度数值，java有两种高精度的计算，BigInteger，`BigDecimal`。这两个类也被归为包装类
		
		
		类和字段：当我们创建好一个类之后，我们可以往类里存放两种类型的元素：方法（method）和字段（field）。类的字段可以是基本类型，也可以是引用类型。
		
		命名可见性：Java 采取了一种新的方法避免了以上这些问题：为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。因此我的域名是 MindviewInc.com，所以我将我的 foibles 类库命名为 com.mindviewinc.utility.foibles。反转域名后，`.` 用来代表子目录的划分。
		

		
		Static关键字
			-类是对象的外观及行为方式的描述。通常只有在使用 `new` 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。   **static** 关键字（从 C++ 采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。
			
			我们可以使用static关键字在类的字段或方法前添加static 表示这是一个静态字段和静态方法。
			例如：
			class Test{
				static int i=9;
			}
			
			当我创建两个Test类的对象实例时，每个对象都包括 i这个属性，但是静态变量仍然只会占一份存储空间。两个对象就会共享同一份数据。
			
## 运算符
	
	赋值
		运算符的赋值是由符号 `=` 完成的，如果是基本类似数据赋值都是直接的，如果是对象赋值就不一样，而是赋值引用。
		
	自增和自减
		对于前递增和前递减（如 `++a` 或 `--a`），会先执行递增/减运算，再返回值。而对于后递增和后递减（如 `a++` 或 `a--`），会先返回值，再执行递增/减运算。
	
	
	
	** Integer 自动装箱，自动拆箱
			public class Equivalence {
	    public static void main(String[] args) {
	        Integer n1 = 47;
	        Integer n2 = 47;
	        System.out.println(n1 == n2);
	        System.out.println(n1 != n2);
	    }
	}
		
		输出结果为：true false
		这里有一个常见的陷阱， == 比较时除去基本类型都是引用的比较，第一个输出应该是false，因为 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 `==` 和 `!=` 比较也能能到正确的结果，但是不推荐用关系运算符比较，具体见 JDK 中的 Integer 类源码）。
		因此，我们不推荐使用==比较，使用equals来比较。当然，我们也要注意equals的默认行为是比较对象的引用而不是内容。此时，我们就需要重写equals。
		
		
	下划线
		java中可以使用下划线，来使结果更清晰。例如：
		
			public class Underscores {
    public static void main(String[] args) {
        double d = 341_435_936.445_667;
        System.out.println(d);
        int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111;
        System.out.println(Integer.toBinaryString(bin));
        System.out.printf("%x%n", bin); // [1]
        long hex = 0x7f_e9_b7_aa;
        System.out.printf("%x%n", hex);
    }
}

		1. 仅限单 `_`，不能多条相连。
		2. 数值开头和结尾不允许出现 `_`。
		3. `F`、`D` 和 `L`的前后禁止出现 `_`。
		4. 二进制前导 `b` 和 十六进制 `x` 前后禁止出现 `_`

------------------------------------------------------------------------------------------------------------------




## 初始化和清理
	

	构造器保证初始化
		Java 中使用了同样的方式：构造器名称与类名相同。在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。
	
	方法重载
		每个被重载的方法必须有独一无二的参数列表。
			1.参数的顺序
			2.参数的类型
	
	无参构造器
		如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。如果显式的创建了有参构造器，系统就不会给你创建默认的无参构造器。
		
	this关键字
		引入问题，例如：
		class Banana {
		    void peel(int i) {
		        /*...*/
		    }
		}
		public class BananaPeel {
		    public static void main(String[] args) {
		        Banana a = new Banana(), b = new Banana();
		        a.peel(1);
		        b.peel(2);
		    }
		}
		
		两个相同类型的对象，都想调用同一个方法peel，就可以使用this来完成这一工作。如果只有一个方法 `peel()` ，那么怎么知道调用的是对象 **a** 的 `peel()`方法还是对象 **b** 的 `peel()` 方法呢？编译器做了一些底层工作，所以你可以像这样编写代码。`peel()` 方法中第一个参数隐密地传入了一个指向操作对象的引用。因此，上述例子中的方法调用像下面这样：
		Banana.peel(a, 1)
		Banana.peel(b, 1)
		
		
		这都是在内部实现的，我们不能这样编写代码，编译器不同通过，但可以说明发生了什么。想要获得当前对象的引用，但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，this关键可以实现这一切。this关键字只能在非静态方法中使用，当我们调用一个方法的时候，this生成了一个对象引用。
		
		如果你在一个类的方法里调用其他该类中的方法，不要使用 **this**，直接调用即可，**this** 自动地应用于其他方法上了，编译器会帮我们做这些工作。this关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在 **return** 语句中返回对当前对象的引用,**this** 关键字在向其他方法传递当前对象时也很有用,this也可以在构造器里面调用其它构造器。
		实例demo02,demo03
		
		
		static的含义
			**static** 方法中不会存在 **this**。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 **this**，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 **static** 方法，就该重新考虑自己的设计了。然而，**static** 的概念很实用，许多时候都要用到它。
		
		
		垃圾回收器
			使用完一个对象不管它并非是安全的，java中垃圾回收器回收无用对象占用的内存。现在有一种特殊情况，创建的对象不是new出来的，而垃圾回收器只知道释放new出来的对象内存。为了处理这一类情况，java使用了finalize()方法。
			它的工作原理"假定"是这样的：当垃圾回收器准备回收对象的内存时，首先会调用其 `finalize()` 方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用 `finalize()` ，就能在垃圾回收时做一些重要的清理工作。`finalize()` 是一个潜在的编程陷阱，因为一些程序员（尤其是 C++ 程序员）会一开始把它误认为是 C++ 中的析构函数（C++ 在销毁对象时会调用这个函数）。所以有必要明确区分一下：在 C++ 中，对象总是被销毁的（在一个 bug-free 的程序中），而在 Java 中，对象并非总是被垃圾回收，或者换句话说：
	
			1. 对象可能不被垃圾回收。
			2. 垃圾回收不等同于析构。
			
			当我们不需要某个对象之前，如果必须执行某个工作，你就得自己去做。java没有c++折构器的概念，所以我们必须创建某个方法自己来实现垃圾清理，编写finalize()方法，垃圾回收器不会立马回收，当垃圾回收器某些机制触发工作时垃圾回收器就会被调用finalize()
			
			只要程序没有濒临内存用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，而垃圾回收器一直没有释放你创建的任何对象的内存，则当程序退出时，那些资源会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。
			
			finalize()的用途：
				1.垃圾回收只会于内存有关，垃圾回收就是使程序不再使用相应的内存，所以垃圾回收有关的任何行为（fuinalize()方法），他也同内存及其回收有关。
				
				这是否意味着如果对象中包括其他对象，`finalize()` 方法就应该明确释放那些对象呢？不是，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的所有内存。这就将对 `finalize()` 的需求限制到一种特殊情况，即通过某种创建对象方式之外的方式为对象分配了存储空间。
				看起来之所以有 `finalize()` 方法，是因为在分配内存时可能采用了类似 C 语言中的做法，而非 Java 中的通常做法。这种情况主要发生在使用"本地方法"的情况下，本地方法是一种用 Java 语言调用非 Java 语言代码的形式，本地方法目前只支持 C 和 C++，但是它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非 Java 代码中，也许会调用 C 的 `malloc()` 函数系列来分配存储空间，而且除非调用 `free()` 函数，不然存储空间永远得不到释放，造成内存泄露。但是，`free()` 是 C 和 C++ 中的函数，所以你需要在 `finalize()` 方法里用本地方法调用它。
				
				所有finalize()方法的特性就决定了他不会过多的使用，那清理工作在何处执行呢？
					
				要清理一个对象，用户必须在需要清理的时候调用执行清理动作的方法.java中不需要向C++那样使用折构函数。我们甚至可以肤浅的认为由于垃圾回收器的存在，使得java没有折构函数。但是垃圾回收器绝对不可能完整替代折构函数，而且绝对不能直接调用fanalize方法，如果希望进行除释放存储空间之外的清理工作，还是得明确调用某个恰当的 Java 方法：这就等同于使用析构函数了，只是没有它方便。
				记住，无论是"垃圾回收"还是"终结"，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。	
				
			终结的条件：
				通常不指望finaliz方法，你必须创建其他的清理方法，并且调用它。所以看起来，`finalize()` 只对大部分程序员很难用到的一些晦涩内存清理里有用了。但是，`finalize()` 还有一个有趣的用法，它不依赖于每次都要对 `finalize()` 进行调用，这就是对象终结条件的验证。
				
				当对某个对象不感兴趣时——也就是它将被清理了，这个对象应该处于某种状态，这种状态下它占用的内存可以被安全地释放掉。下是个简单的例子，示范了 `finalize()` 的可能使用方式：Book.java
		
		垃圾回收器如何工作：
			垃圾回收器能很明显地提高对象的创建速度。这听起来很奇怪——存储空间的释放影响了存储空间的分配，但这确实是某些 Java 虚拟机的工作方式。这也意味着，Java 从堆空间分配的速度可以和其他语言在栈上分配空间的速度相媲美。
			，你可以把 C++ 里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。在某些 Java 虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。Java 的"堆指针"只是简单地移动到尚未分配的区域，所以它的效率与 C++ 在栈上分配空间的效率相当。当然实际过程中，在簿记工作方面还有少量额外开销，但是这部分开销比不上查找可用空间开销大。
			Java 中的堆并非完全像传送带那样工作。要是那样的话，势必会导致频繁的内存页面调度——将其移进移出硬盘，因此会显得需要拥有比实际需要更多的内存。页面调度会显著影响性能。最终，在创建了足够多的对象后，内存资源被耗尽。其中的秘密在于垃圾回收器的介入。当它工作时，一边回收内存，一边使堆中的对象紧凑排列，这样"堆指针"就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。
			
			要想理解 Java 中的垃圾回收，先了解其他系统中的垃圾回收机制将会很有帮助。一种简单但速度很慢的垃圾回收机制叫做*引用计数*。每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 **null** 时，引用计数减 1。因此，管理引用计数是一个开销不大但是在程序的整个生命周期频繁发生的负担。垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为 0 时，就释放其占用的空间（但是，引用计数模式经常会在计数为 0 时立即释放对象）。这个机制存在一个缺点：如果对象之间存在循环引用，那么它们的引用计数都不为 0，就会出现应该被回收但无法被回收的情况。对垃圾回收器而言，定位这样的循环引用所需的工作量极大。引用计数常用来说明垃圾回收的工作方式，但似乎从未被应用于任何一种 Java 虚拟机实现中。
			在更快的策略中，垃圾回收器并非基于引用计数。它们依据的是：对于任意"活"的对象，一定能最终追溯到其存活在栈或静态存储区中的引用。这个引用链条可能会穿过数个对象层次，由此，如果从栈或静态存储区出发，遍历所有的引用，你将会发现所有"活"的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是该对象包含的所有引用，如此反复进行，直到访问完"根源于栈或静态存储区的引用"所形成的整个网络。你所访问过的对象一定是"活"的。注意，这解决了对象间循环引用的问题，这些对象不会被发现，因此也就被自动回收了。

		在这种方式下，Java 虚拟机采用了一种*自适应*的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的 Java 虚拟机实现。其中有一种做法叫做停止-复制（stop-and-copy）。顾名思义，这需要先暂停程序的运行（不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。另外，当对象被复制到新堆时，它们是一个挨着一个紧凑排列，然后就可以按照前面描述的那样简单、直接地分配新空间了。

		当对象从一处复制到另一处，所有指向它的引用都必须修正。位于栈或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成一个表格，将旧地址映射到新地址）。
		
		这种所谓的"复制回收器"效率低下主要因为两个原因。其一：得有两个堆，然后在这两个分离的堆之间来回折腾，得维护比实际需要多一倍的空间。某些 Java 虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。
		
		其二在于复制本身。一旦程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。为了避免这种状况，一些 Java 虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种模式（即"自适应"）。这种模式称为标记-清扫（mark-and-sweep），Sun 公司早期版本的 Java 虚拟机一直使用这种技术。对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。
		
		"标记-清扫"所依据的思路仍然是从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活对象，就给对象设一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。"标记-清扫"后剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就需要重新整理剩下的对象。
		
		"停止-复制"指的是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会暂停。在 Oracle 公司的文档中会发现，许多参考文献将垃圾回收视为低优先级的后台进程，但是早期版本的 Java 虚拟机并不是这么实现垃圾回收器的。当可用内存较低时，垃圾回收器会暂停程序。同样，"标记-清扫"工作也必须在程序暂停的情况下才能进行。
		
		如前文所述，这里讨论的 Java 虚拟机中，内存分配以较大的"块"为单位。如果对象较大，它会占用单独的块。严格来说，"停止-复制"要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆，这导致了大量的内存复制行为。有了块，垃圾回收器就可以把对象复制到废弃的块。每个块都有年代数来记录自己是否存活。通常，如果块在某处被引用，其年代数加 1，垃圾回收器会对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会复制（只是年代数会增加），含有小型对象的那些块则被复制并整理。Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到"标记-清扫"方式。同样，Java 虚拟机会跟踪"标记-清扫"的效果，如果堆空间出现很多碎片，就会切换回"停止-复制"方式。这就是"自适应"的由来，你可以给它个啰嗦的称呼："自适应的、分代的、停止-复制、标记-清扫"式的垃圾回收器。
		
		Java 虚拟机中有许多附加技术用来提升速度。尤其是与加载器操作有关的，被称为"即时"（Just-In-Time, JIT）编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码，所以不需要 JVM 来进行翻译，因此运行得更快。当需要装载某个类（通常是创建该类的第一个对象）时，编译器会先找到其 **.class** 文件，然后将该类的字节码装入内存。你可以让即时编译器编译所有代码，但这种做法有两个缺点：一是这种加载动作贯穿整个程序生命周期内，累加起来需要花更多时间；二是会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这会导致页面调度，从而一定降低程序速度。另一种做法称为*惰性评估*，意味着即时编译器只有在必要的时候才编译代码。这样，从未被执行的代码也许就压根不会被 JIT 编译。新版 JDK 中的 Java HotSpot 技术就采用了类似的做法，代码每被执行一次就优化一些，所以执行的次数越多，它的速度就越快。
		
		Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行	|------------------------------->jit即时编译器-------------|
										惰性评估
										
		******************************************************************************************************
		
		
		初始化：
			1.成员初始化
				指定初始化
			2.构造器初始化
				初始化顺序
				静态数据初始化
				显式的静态初始化
				非静态初始化
			3.数组初始化
				动态数组的创建
				可变参数列表
			
------------------------------------------------------------------------------------------------------------------
	
		1.成员初始化
			类的成员变量是基本类型，情况就会变得有些不同。正如在"万物皆对象"一章中所看到的，类的每个基本类型数据成员保证都会有一个初始值。在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为 **null**。
			
		2.构造器初始化
			构造器初始化，具有极大的灵活性，因为你可以在运行时调用方法进行初始化。
			Window.class 
			
			静态数据初始化
			无论创建多少个对象，静态数据都只占用一份存储区域。**static** 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。
			有staticInit 中由输出可见，静态初始化只有在必要时刻才会进行。如果不创建 **Table** 对象，也不引用 **Table.bowl1** 或 **Table.bowl2**，那么静态的 **Bowl** 类对象 **bowl1** 和 **bowl2** 永远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化。
			且在Cupboard.class中Bowl(3)定义在4，5之前由此可以看出，静态对象优先于非静态对象
			要执行 `main()` 方法，必须加载 **StaticInitialization** 类，它的静态属性 **table** 和 **cupboard** 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 **Bowl** 对象，所以 **Bowl** 类也会被加载。
			
			1我们可以得出一个结论：当创建对象时，即时没有Static修饰构造方法，构造器也就是一个静态方法。所以，首次创建类实例或首次访问该类的静态属性时，java解释器必须在类的路径中寻找，以定位Class文件。
			2.当加载完Class文件后就会创建该class对象，有关的静态初始化动作都会被执行。因此静态数据初始化都只会在首次加载class对象后初始化一次。
			3.当new 创建对象实例时，就会在堆内存分配内存空间。
			4.分配的存储空间首先都会被清零，类实例中的基本数据类型数据都会被设置为默认值(数字类型为 0，引用类型为Null)
			5.执行类字段中定义的初始化动作
			6.执行构造器。
			
			显示数据初始化(又叫做静态代码块)如下：
			
				public class Spoon {
				    static int i;
				    
				    static {
				        i = 47;
				    }
				}
			
			与其让静态数据一样，静态代码块初始一次。
			
			
			
			非静态实例初始化
			Java 提供了被称为*实例初始化*的类似语法，用来初始化每个对象的非静态变量，例如：Mus.class
			输出看出，实例初始化子句是在两个构造器之前执行的。
			
			
		数组初始化
			
			编译器不允许指定数组的大小。这又把我们带回有关"引用"的问题上。你所拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。
			例如：int[] a1 = {1, 2, 3, 4, 5}; int[] a2;
			a2 =a1 ;赋值引用
			
			动态数组创建
				int[] a;
		        Random rand = new Random(47);
		        a = new int[rand.nextInt(20)];
		        
			        例二：public class ArrayInit {
			    public static void main(String[] args) {
			        Integer[] a = {
			                1, 2,
			                3, // Autoboxing
			        };
			        Integer[] b = new Integer[] {
			                1, 2,
			                3, // Autoboxing
			        };
			        System.out.println(Arrays.toString(a));
			        System.out.println(Arrays.toString(b));
			
			    }
			}
			
			在这两种形式之中，初始化列表的最后一个逗号
			尽管第一种形式很有用，但是它更加受限，因为它只能用于数组定义处。第二种和第三种形式可以用在任何地方，甚至用在方法的内部。例如，你创建了一个 **String** 数组，将其传递给另一个类的 `main()` 方法，如DynamicArray.java
			
			
			可变参数列表
				创建一个类似Object数组为参数的方法，并像VarArgs.java
				有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么 `printArray()` 可以使用 for-in 迭代数组的原因。可变参数可以使用任何类型。
				
			然而，可变参数列表与自动装箱可以和谐共处，如下：
				public class AutoboxingVarargs {
				    public static void f(Integer... args) {
				        for (Integer i: args) {
				            System.out.print(i + " ");
				        }
				        System.out.println();
				    }
				    
				    public static void main(String[] args) {
				        f(1, 2);
				        f(4, 5, 6, 7, 8, 9);
				        f(10, 11, 12);
				        
				    }
				}
				在每种情况下，编译器都会使用自动装箱来匹配重载的方法，然后调用最明确匹配的方法。
					
				
		枚举
			由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示（如果名称中含有多个单词，使用下划线分隔）。
			
			在你创建 **enum** 时，编译器会自动添加一些有用的特性。例如，它会创建 `toString()` 方法，以便你方便地显示某个 **enum** 实例的名称，这从上面例子中的输出可以看出。编译器还会创建 `ordinal()` 方法表示某个特定 **enum** 常量的声明顺序，`static values()` 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组
			参照Enum.java
			
			尽管 **enum** 看起来像是一种新的数据类型，但是这个关键字只是在生成 **enum** 的类时，产生了某些编译器行为，因此在很大程度上你可以将 **enum** 当作其他任何类。事实上，**enum** 确实是类，并且具有自己的方法。
			
			如果你将enum当作常量数组来使用那就大错特错，enum有一个极佳的特性，就是与switch语句联合使用。
			
==================================================================================================================
##封装

		
		