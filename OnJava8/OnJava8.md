# On Java 8 thinking
	目录
	-1.什么是对象
	-2.万物皆对象
	-3.运算符
	-4.初始化和清理
	-5.封装
	-6.继承和复用
	-7.多态
	-8.接口
	-9内部类
	-10.容器
	-11.函数式编程
	-12.流式编程
	-13.异常
	-14.校验代码
	-15.文件
	-16.字符串
	-17.类型信息
	-18.泛型
	-19.数组
	-20.枚举
	-21.注解
	-22.多线程
	-23反射
	-24.设计模式


​	


## 什么是对象
	>
	
	面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种表达非常具有普遍性，所以不	必受限于特定类型的问题。我们将问题空间中的元素以及它们在解决方案空间的表示称作“对象”（**Object**）。	
	
	我们可以理解纯粹的面向对象程序设计方法：
		-1.万物皆对象
		-2.**程序是一组对象，通过消息传递来告知彼此该做什么**
		-3.每个对象都有自己的存储空间，可容纳其他对象
		-4.**每个对象都有一种类型**
		-5.**同一类所有对象都能接收相同的消息**
	>
	
	聚合和组合
		>
		组合和聚合都属于关联关系的一种，只是额外具有整体-部分的意义。至于是聚合还是组合，需要根据实际的业务需求来判断。可能相同超类和子类，在不同的业务场景，关联关系会发生变化。只看代码是无法区分聚合和组合的，具体是哪一种关系，只能从语义级别来区分。聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。
		
			“组合”关系给我们的程序带来极大的灵活性。 一半会使用private 访问权限
		>
	$$"是一个"与"像是一个"的关系
	在子类继承父类时，如果子类没有扩展该类的元素，这就是一种is a关系，若子类扩展本类的元素虽然新类型仍然可以替代基类，但是这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。


​	
​	多态
​		>
​		可以通过通用的“形状”基类派生出新的“五角形”形状的子类，而不需要修改通用"形状"基类的方法。通过派生新的子类来扩展设计的这种能力是封装变化的基本方法之一。
​		
​		早期绑定：译器生成对特定函数名的调用，该调用会被解析为将执行的代码的绝对地址。
​		后期绑定：当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码


​				为了执行后期绑定，Java 使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址。
​		
​		>
​	对象创建与生命周期
​		栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间
​		第二种方法是在堆内存（Heap）中动态地创建对象。
​		在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。

		Java 使用动态内存分配。每次创建对象时，使用 `new` 关键字构建该对象的动态实例。这又带来另一个问题：对象的生命周期。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。
---------------------------------------------------------------------------------------------------------------------------------------

##万物皆对象
	

	对象的操作底层使用的是指针，但我们操作的标识符实际上是对象的引用， 举例：我们可以用遥控器（引用）去操纵电视（对象）。
	例如：
		String str;这就是一个string对象的引用，对象的引用而非对象，直接使用会出现错误，因为没有给对象赋值，也就是通常所说的指向对象，通常安全的做法是创建一个引用并且同时进行初始化。
	例如：	String str =“hello”
	也可以使用new关键字创建对象实例	String str = new String("hello");


​	
​	**数据存储**
​		1.**寄存器**（Registers）最快的存储区域，位于 CPU 内部 
​		2.**栈内存**（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java 系统必须准确地知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据，特别是对象引用，但!! Java 对象却是保存在堆内存的!!	
​		3.**堆内存**（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。
​		4.**常量存储**（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 [^3]。
​		5.**非 RAM 存储**（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。
​		
​		$$java语言的基本数据类型内存占用的大小不会像其他语言一样随机器的变化而变化。


		| 基本类型 |  大小   |      最小值      |          最大值           | 包装类型  |
		| :------: | :-----: | :--------------: | :-----------------------: | :-------: |
		| boolean  |    —    |        —         |             —             |  Boolean  |
		|   char   | 16 bits |    Unicode 0     | Unicode 2<sup>16</sup> -1 | Character |
		|   byte   | 8 bits  |       -128       |           +127            |   Byte    |
		|  short   | 16 bits | - 2<sup>15</sup> |    + 2<sup>15</sup> -1    |   Short   |
		|   int    | 32 bits | - 2<sup>31</sup> |    + 2<sup>31</sup> -1    |  Integer  |
		|   long   | 64 bits | - 2<sup>63</sup> |    + 2<sup>63</sup> -1    |   Long    |
		|  float   | 32 bits |     IEEE754      |          IEEE754          |   Float   |
		|  double  | 64 bits |     IEEE754      |          IEEE754          |  Double   |
		|   void   |    —    |        —         |             —             |   Void    |


​	
​		高精度数值，java有两种高精度的计算，BigInteger，`BigDecimal`。这两个类也被归为包装类


​		
​		类和字段：当我们创建好一个类之后，我们可以往类里存放两种类型的元素：方法（method）和字段（field）。类的字段可以是基本类型，也可以是引用类型。
​		
​		命名可见性：Java 采取了一种新的方法避免了以上这些问题：为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。因此我的域名是 MindviewInc.com，所以我将我的 foibles 类库命名为 com.mindviewinc.utility.foibles。反转域名后，`.` 用来代表子目录的划分。


​		
​		Static关键字
​			-类是对象的外观及行为方式的描述。通常只有在使用 `new` 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。   **static** 关键字（从 C++ 采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。
​			
​			我们可以使用static关键字在类的字段或方法前添加static 表示这是一个静态字段和静态方法。
​			例如：
​			class Test{
​				static int i=9;
​			}
​			
​			当我创建两个Test类的对象实例时，每个对象都包括 i这个属性，但是静态变量仍然只会占一份存储空间。两个对象就会共享同一份数据。

## 运算符

	赋值
		运算符的赋值是由符号 `=` 完成的，如果是基本类似数据赋值都是直接的，如果是对象赋值就不一样，而是赋值引用。
		
	自增和自减
		对于前递增和前递减（如 `++a` 或 `--a`），会先执行递增/减运算，再返回值。而对于后递增和后递减（如 `a++` 或 `a--`），会先返回值，再执行递增/减运算。


​	
​	
​	** Integer 自动装箱，自动拆箱
​			public class Equivalence {
​	    public static void main(String[] args) {
​	        Integer n1 = 47;
​	        Integer n2 = 47;
​	        System.out.println(n1 == n2);
​	        System.out.println(n1 != n2);
​	    }
​	}
​		
​		输出结果为：true false
​		这里有一个常见的陷阱， == 比较时除去基本类型都是引用的比较，第一个输出应该是false，因为 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 `==` 和 `!=` 比较也能能到正确的结果，但是不推荐用关系运算符比较，具体见 JDK 中的 Integer 类源码）。
​		因此，我们不推荐使用==比较，使用equals来比较。当然，我们也要注意equals的默认行为是比较对象的引用而不是内容。此时，我们就需要重写equals。


​		
​	下划线
​		java中可以使用下划线，来使结果更清晰。例如：
​		
​			public class Underscores {
​	public static void main(String[] args) {
​	    double d = 341_435_936.445_667;
​	    System.out.println(d);
​	    int bin = 0b0010_1111_1010_1111_1010_1111_1010_1111;
​	    System.out.println(Integer.toBinaryString(bin));
​	    System.out.printf("%x%n", bin); // [1]
​	    long hex = 0x7f_e9_b7_aa;
​	    System.out.printf("%x%n", hex);
​	}
}

		1. 仅限单 `_`，不能多条相连。
		2. 数值开头和结尾不允许出现 `_`。
		3. `F`、`D` 和 `L`的前后禁止出现 `_`。
		4. 二进制前导 `b` 和 十六进制 `x` 前后禁止出现 `_`

------------------------------------------------------------------------------------------------------------------




## 初始化和清理


	构造器保证初始化
		Java 中使用了同样的方式：构造器名称与类名相同。在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。
	
	方法重载
		每个被重载的方法必须有独一无二的参数列表。
			1.参数的顺序
			2.参数的类型
	
	无参构造器
		如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。如果显式的创建了有参构造器，系统就不会给你创建默认的无参构造器。
		
	this关键字
		引入问题，例如：
		class Banana {
		    void peel(int i) {
		        /*...*/
		    }
		}
		public class BananaPeel {
		    public static void main(String[] args) {
		        Banana a = new Banana(), b = new Banana();
		        a.peel(1);
		        b.peel(2);
		    }
		}
		
		两个相同类型的对象，都想调用同一个方法peel，就可以使用this来完成这一工作。如果只有一个方法 `peel()` ，那么怎么知道调用的是对象 **a** 的 `peel()`方法还是对象 **b** 的 `peel()` 方法呢？编译器做了一些底层工作，所以你可以像这样编写代码。`peel()` 方法中第一个参数隐密地传入了一个指向操作对象的引用。因此，上述例子中的方法调用像下面这样：
		Banana.peel(a, 1)
		Banana.peel(b, 1)


​		
​		这都是在内部实现的，我们不能这样编写代码，编译器不同通过，但可以说明发生了什么。想要获得当前对象的引用，但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，this关键可以实现这一切。this关键字只能在非静态方法中使用，当我们调用一个方法的时候，this生成了一个对象引用。
​		
​		如果你在一个类的方法里调用其他该类中的方法，不要使用 **this**，直接调用即可，**this** 自动地应用于其他方法上了，编译器会帮我们做这些工作。this关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在 **return** 语句中返回对当前对象的引用,**this** 关键字在向其他方法传递当前对象时也很有用,this也可以在构造器里面调用其它构造器。
​		实例demo02,demo03


​		
​		static的含义
​			**static** 方法中不会存在 **this**。你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 **this**，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 **static** 方法，就该重新考虑自己的设计了。然而，**static** 的概念很实用，许多时候都要用到它。


​		
​		垃圾回收器
​			使用完一个对象不管它并非是安全的，java中垃圾回收器回收无用对象占用的内存。现在有一种特殊情况，创建的对象不是new出来的，而垃圾回收器只知道释放new出来的对象内存。为了处理这一类情况，java使用了finalize()方法。
​			它的工作原理"假定"是这样的：当垃圾回收器准备回收对象的内存时，首先会调用其 `finalize()` 方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用 `finalize()` ，就能在垃圾回收时做一些重要的清理工作。`finalize()` 是一个潜在的编程陷阱，因为一些程序员（尤其是 C++ 程序员）会一开始把它误认为是 C++ 中的析构函数（C++ 在销毁对象时会调用这个函数）。所以有必要明确区分一下：在 C++ 中，对象总是被销毁的（在一个 bug-free 的程序中），而在 Java 中，对象并非总是被垃圾回收，或者换句话说：
​	
​			1. 对象可能不被垃圾回收。
​			2. 垃圾回收不等同于析构。
​			
​			当我们不需要某个对象之前，如果必须执行某个工作，你就得自己去做。java没有c++折构器的概念，所以我们必须创建某个方法自己来实现垃圾清理，编写finalize()方法，垃圾回收器不会立马回收，当垃圾回收器某些机制触发工作时垃圾回收器就会被调用finalize()
​			
​			只要程序没有濒临内存用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，而垃圾回收器一直没有释放你创建的任何对象的内存，则当程序退出时，那些资源会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。
​			
​			finalize()的用途：
​				1.垃圾回收只会于内存有关，垃圾回收就是使程序不再使用相应的内存，所以垃圾回收有关的任何行为（fuinalize()方法），他也同内存及其回收有关。
​				
​				这是否意味着如果对象中包括其他对象，`finalize()` 方法就应该明确释放那些对象呢？不是，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的所有内存。这就将对 `finalize()` 的需求限制到一种特殊情况，即通过某种创建对象方式之外的方式为对象分配了存储空间。
​				看起来之所以有 `finalize()` 方法，是因为在分配内存时可能采用了类似 C 语言中的做法，而非 Java 中的通常做法。这种情况主要发生在使用"本地方法"的情况下，本地方法是一种用 Java 语言调用非 Java 语言代码的形式，本地方法目前只支持 C 和 C++，但是它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非 Java 代码中，也许会调用 C 的 `malloc()` 函数系列来分配存储空间，而且除非调用 `free()` 函数，不然存储空间永远得不到释放，造成内存泄露。但是，`free()` 是 C 和 C++ 中的函数，所以你需要在 `finalize()` 方法里用本地方法调用它。
​				
​				所有finalize()方法的特性就决定了他不会过多的使用，那清理工作在何处执行呢？
​					
​				要清理一个对象，用户必须在需要清理的时候调用执行清理动作的方法.java中不需要向C++那样使用折构函数。我们甚至可以肤浅的认为由于垃圾回收器的存在，使得java没有折构函数。但是垃圾回收器绝对不可能完整替代折构函数，而且绝对不能直接调用fanalize方法，如果希望进行除释放存储空间之外的清理工作，还是得明确调用某个恰当的 Java 方法：这就等同于使用析构函数了，只是没有它方便。
​				记住，无论是"垃圾回收"还是"终结"，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。	
​				
​			终结的条件：
​				通常不指望finaliz方法，你必须创建其他的清理方法，并且调用它。所以看起来，`finalize()` 只对大部分程序员很难用到的一些晦涩内存清理里有用了。但是，`finalize()` 还有一个有趣的用法，它不依赖于每次都要对 `finalize()` 进行调用，这就是对象终结条件的验证。
​				
​				当对某个对象不感兴趣时——也就是它将被清理了，这个对象应该处于某种状态，这种状态下它占用的内存可以被安全地释放掉。下是个简单的例子，示范了 `finalize()` 的可能使用方式：Book.java
​		
​		垃圾回收器如何工作：
​			垃圾回收器能很明显地提高对象的创建速度。这听起来很奇怪——存储空间的释放影响了存储空间的分配，但这确实是某些 Java 虚拟机的工作方式。这也意味着，Java 从堆空间分配的速度可以和其他语言在栈上分配空间的速度相媲美。
​			，你可以把 C++ 里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。在某些 Java 虚拟机中，堆的实现截然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。Java 的"堆指针"只是简单地移动到尚未分配的区域，所以它的效率与 C++ 在栈上分配空间的效率相当。当然实际过程中，在簿记工作方面还有少量额外开销，但是这部分开销比不上查找可用空间开销大。
​			Java 中的堆并非完全像传送带那样工作。要是那样的话，势必会导致频繁的内存页面调度——将其移进移出硬盘，因此会显得需要拥有比实际需要更多的内存。页面调度会显著影响性能。最终，在创建了足够多的对象后，内存资源被耗尽。其中的秘密在于垃圾回收器的介入。当它工作时，一边回收内存，一边使堆中的对象紧凑排列，这样"堆指针"就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。
​			
​			要想理解 Java 中的垃圾回收，先了解其他系统中的垃圾回收机制将会很有帮助。一种简单但速度很慢的垃圾回收机制叫做*引用计数*。每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 **null** 时，引用计数减 1。因此，管理引用计数是一个开销不大但是在程序的整个生命周期频繁发生的负担。垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为 0 时，就释放其占用的空间（但是，引用计数模式经常会在计数为 0 时立即释放对象）。这个机制存在一个缺点：如果对象之间存在循环引用，那么它们的引用计数都不为 0，就会出现应该被回收但无法被回收的情况。对垃圾回收器而言，定位这样的循环引用所需的工作量极大。引用计数常用来说明垃圾回收的工作方式，但似乎从未被应用于任何一种 Java 虚拟机实现中。
​			在更快的策略中，垃圾回收器并非基于引用计数。它们依据的是：对于任意"活"的对象，一定能最终追溯到其存活在栈或静态存储区中的引用。这个引用链条可能会穿过数个对象层次，由此，如果从栈或静态存储区出发，遍历所有的引用，你将会发现所有"活"的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是该对象包含的所有引用，如此反复进行，直到访问完"根源于栈或静态存储区的引用"所形成的整个网络。你所访问过的对象一定是"活"的。注意，这解决了对象间循环引用的问题，这些对象不会被发现，因此也就被自动回收了。
​	
​		在这种方式下，Java 虚拟机采用了一种*自适应*的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的 Java 虚拟机实现。其中有一种做法叫做停止-复制（stop-and-copy）。顾名思义，这需要先暂停程序的运行（不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。另外，当对象被复制到新堆时，它们是一个挨着一个紧凑排列，然后就可以按照前面描述的那样简单、直接地分配新空间了。
​	
		当对象从一处复制到另一处，所有指向它的引用都必须修正。位于栈或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成一个表格，将旧地址映射到新地址）。
		
		这种所谓的"复制回收器"效率低下主要因为两个原因。其一：得有两个堆，然后在这两个分离的堆之间来回折腾，得维护比实际需要多一倍的空间。某些 Java 虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。
		
		其二在于复制本身。一旦程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。为了避免这种状况，一些 Java 虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种模式（即"自适应"）。这种模式称为标记-清扫（mark-and-sweep），Sun 公司早期版本的 Java 虚拟机一直使用这种技术。对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。
		
		"标记-清扫"所依据的思路仍然是从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活对象，就给对象设一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。"标记-清扫"后剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就需要重新整理剩下的对象。
		
		"停止-复制"指的是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会暂停。在 Oracle 公司的文档中会发现，许多参考文献将垃圾回收视为低优先级的后台进程，但是早期版本的 Java 虚拟机并不是这么实现垃圾回收器的。当可用内存较低时，垃圾回收器会暂停程序。同样，"标记-清扫"工作也必须在程序暂停的情况下才能进行。
		
		如前文所述，这里讨论的 Java 虚拟机中，内存分配以较大的"块"为单位。如果对象较大，它会占用单独的块。严格来说，"停止-复制"要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆，这导致了大量的内存复制行为。有了块，垃圾回收器就可以把对象复制到废弃的块。每个块都有年代数来记录自己是否存活。通常，如果块在某处被引用，其年代数加 1，垃圾回收器会对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会复制（只是年代数会增加），含有小型对象的那些块则被复制并整理。Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到"标记-清扫"方式。同样，Java 虚拟机会跟踪"标记-清扫"的效果，如果堆空间出现很多碎片，就会切换回"停止-复制"方式。这就是"自适应"的由来，你可以给它个啰嗦的称呼："自适应的、分代的、停止-复制、标记-清扫"式的垃圾回收器。
		
		Java 虚拟机中有许多附加技术用来提升速度。尤其是与加载器操作有关的，被称为"即时"（Just-In-Time, JIT）编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码，所以不需要 JVM 来进行翻译，因此运行得更快。当需要装载某个类（通常是创建该类的第一个对象）时，编译器会先找到其 **.class** 文件，然后将该类的字节码装入内存。你可以让即时编译器编译所有代码，但这种做法有两个缺点：一是这种加载动作贯穿整个程序生命周期内，累加起来需要花更多时间；二是会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这会导致页面调度，从而一定降低程序速度。另一种做法称为*惰性评估*，意味着即时编译器只有在必要的时候才编译代码。这样，从未被执行的代码也许就压根不会被 JIT 编译。新版 JDK 中的 Java HotSpot 技术就采用了类似的做法，代码每被执行一次就优化一些，所以执行的次数越多，它的速度就越快。
		
		Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行	|------------------------------->jit即时编译器-------------|
										惰性评估
										
		******************************************************************************************************


​		
​		初始化：
​			1.成员初始化
​				指定初始化
​			2.构造器初始化
​				初始化顺序
​				静态数据初始化
​				显式的静态初始化
​				非静态初始化
​			3.数组初始化
​				动态数组的创建
​				可变参数列表

------------------------------------------------------------------------------------------------------------------

		1.成员初始化
			类的成员变量是基本类型，情况就会变得有些不同。正如在"万物皆对象"一章中所看到的，类的每个基本类型数据成员保证都会有一个初始值。在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为 **null**。
			
		2.构造器初始化
			构造器初始化，具有极大的灵活性，因为你可以在运行时调用方法进行初始化。
			Window.class 
			
			静态数据初始化
			无论创建多少个对象，静态数据都只占用一份存储区域。**static** 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。
			有staticInit 中由输出可见，静态初始化只有在必要时刻才会进行。如果不创建 **Table** 对象，也不引用 **Table.bowl1** 或 **Table.bowl2**，那么静态的 **Bowl** 类对象 **bowl1** 和 **bowl2** 永远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化。
			且在Cupboard.class中Bowl(3)定义在4，5之前由此可以看出，静态对象优先于非静态对象
			要执行 `main()` 方法，必须加载 **StaticInitialization** 类，它的静态属性 **table** 和 **cupboard** 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 **Bowl** 对象，所以 **Bowl** 类也会被加载。
			
			1我们可以得出一个结论：当创建对象时，即时没有Static修饰构造方法，构造器也就是一个静态方法。所以，首次创建类实例或首次访问该类的静态属性时，java解释器必须在类的路径中寻找，以定位Class文件。
			2.当加载完Class文件后就会创建该class对象，有关的静态初始化动作都会被执行。因此静态数据初始化都只会在首次加载class对象后初始化一次。
			3.当new 创建对象实例时，就会在堆内存分配内存空间。
			4.分配的存储空间首先都会被清零，类实例中的基本数据类型数据都会被设置为默认值(数字类型为 0，引用类型为Null)
			5.执行类字段中定义的初始化动作
			6.执行构造器。
			
			显示数据初始化(又叫做静态代码块)如下：
			
				public class Spoon {
				    static int i;
				    
				    static {
				        i = 47;
				    }
				}
			
			与其让静态数据一样，静态代码块初始一次。


​			
​			
​			非静态实例初始化
​			Java 提供了被称为*实例初始化*的类似语法，用来初始化每个对象的非静态变量，例如：Mus.class
​			输出看出，实例初始化子句是在两个构造器之前执行的。


​			
​		数组初始化
​			
​			编译器不允许指定数组的大小。这又把我们带回有关"引用"的问题上。你所拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。
​			例如：int[] a1 = {1, 2, 3, 4, 5}; int[] a2;
​			a2 =a1 ;赋值引用
​			
​			动态数组创建
​				int[] a;
​		        Random rand = new Random(47);
​		        a = new int[rand.nextInt(20)];
​		        
​			        例二：public class ArrayInit {
​			    public static void main(String[] args) {
​			        Integer[] a = {
​			                1, 2,
​			                3, // Autoboxing
​			        };
​			        Integer[] b = new Integer[] {
​			                1, 2,
​			                3, // Autoboxing
​			        };
​			        System.out.println(Arrays.toString(a));
​			        System.out.println(Arrays.toString(b));
​			
​			    }
​			}
​			
​			在这两种形式之中，初始化列表的最后一个逗号
​			尽管第一种形式很有用，但是它更加受限，因为它只能用于数组定义处。第二种和第三种形式可以用在任何地方，甚至用在方法的内部。例如，你创建了一个 **String** 数组，将其传递给另一个类的 `main()` 方法，如DynamicArray.java


​			
​			
​			可变参数列表
​				创建一个类似Object数组为参数的方法，并像VarArgs.java
​				有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么 `printArray()` 可以使用 for-in 迭代数组的原因。可变参数可以使用任何类型。
​				
​			然而，可变参数列表与自动装箱可以和谐共处，如下：
​				public class AutoboxingVarargs {
​				    public static void f(Integer... args) {
​				        for (Integer i: args) {
​				            System.out.print(i + " ");
​				        }
​				        System.out.println();
​				    }
​				    
​				    public static void main(String[] args) {
​				        f(1, 2);
​				        f(4, 5, 6, 7, 8, 9);
​				        f(10, 11, 12);
​				        
​				    }
​				}
​				在每种情况下，编译器都会使用自动装箱来匹配重载的方法，然后调用最明确匹配的方法。


​				
​		枚举
​			由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示（如果名称中含有多个单词，使用下划线分隔）。
​			
​			在你创建 **enum** 时，编译器会自动添加一些有用的特性。例如，它会创建 `toString()` 方法，以便你方便地显示某个 **enum** 实例的名称，这从上面例子中的输出可以看出。编译器还会创建 `ordinal()` 方法表示某个特定 **enum** 常量的声明顺序，`static values()` 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组
​			参照Enum.java
​			
​			尽管 **enum** 看起来像是一种新的数据类型，但是这个关键字只是在生成 **enum** 的类时，产生了某些编译器行为，因此在很大程度上你可以将 **enum** 当作其他任何类。事实上，**enum** 确实是类，并且具有自己的方法。
​			
​			如果你将enum当作常量数组来使用那就大错特错，enum有一个极佳的特性，就是与switch语句联合使用。

==================================================================================================================
##封装
	
	包的概念：为了提供一种管理命名空间的机制，所有类名都是隔离的。类 **A** 中的方法 `f()` 不会与类 **B** 中具有相同签名的方法 `f()` 冲突。
	一个 Java 源代码文件称为一个*编译单元*（有时也称*翻译单元*）。每个编译单元的文件名后缀必须是 **.java**。在编译单元中可以有一个 **public** 类，它的类名必须与文件名相同（包括大小写，但不包括后缀名 **.java**）。每个编译单元中只能有一个 **public** 类，否则编译器不接受。如果这个编译单元中还有其他类，那么在包之外是无法访问到这些类的，因为它们不是 **public** 类，此时它们支持主 **public** 类。
	
	当编译一个.java文件时，.java文件会输出一个class文件给解释器处理，在此期间若是其他语言要想生成可执行文件(例如obj)文件必须要经过链接器或者类库生成器产生的其他同类文件打包到一起就可以执行，java中，可执行文件就是class，他们可以打包成jar文件，由java解释器负责查找，加载，处理。
	类库就是一组类文件，每个源文件通常都含有一个 **public** 类和任意数量的非 **public** 类，因此每个文件都有一个构件。如果把这些组件集中在一起，就需要使用关键字 **package**。
	注意，package 语句必须放在代码的第一行。所以，这就意味编译单元是package类库的一部分，当你要访问编译单元中的public类时，就必须要导入类库(package name)
	
	创建独一无二的包名：倒序域名
		
		一个包会包含很多class文件，java利用了操作系统的层次性，解决了代码的混乱性。
		 **package** 名称分解成你机器上的一个目录，所以当 Java 解释器必须要加载一个 .class 文件时，它能定位到 **.class** 文件所在的位置。首先，它找出环境变量 **CLASSPATH**（通过操作系统设置，有时也能通过 Java 的安装程序或基于 Java 的工具设置）。**CLASSPATH** 包含一个或多个目录，用作查找 .**class** 文件的根目录。从根目录开始，Java 解释器获取包名并将每个句点替换成反斜杠，生成一个基于根目录的路径名（包名 foo.bar.baz 变成 foo\bar\baz 或 foo/bar/baz 或其它，取决于你的操作系统）。然后这个路径与 **CLASSPATH** 的不同项连接，解释器就在这些目录中查找与你所创建的类名称相关的 **.class** 文件（解释器还会查找某些涉及 Java 解释器所在位置的标准目录）。
		 
		 例如：	
		 	包名 com.mindviewinc.simple  CLASSPATH=.;D:\JAVA\LIB;C:\DOC\Java
		 	但是在使用 JAR 文件时，有点不一样。你必须在类路径写清楚 JAR 文件的实际名称，不能仅仅是 JAR 文件所在的目录。
		 	类路径为：CLASSPATH=.;D\JAVA\LIB;C:\flavors\grape.jar
		 	
		 	一旦设置好类路径，下面的文件就可以放在任意目录
		 	eclipse 启动时会让我们选择classPath
			
			自定义python range函数 util Range.class


​		
​	访问权限：
​		Java 访问权限修饰符 **public**，**protected** 和 **private** 位于定义的类名，属性名和方法名之前。每个访问权限修饰符只能控制它所修饰的对象。如果不提供访问修饰符，就会采用默认修饰符，也就是包访问权限。


​		
​		protected 基类的创建者会希望某个特定成员能被继承类访问，但不能被其他类访问。这时就需要使用 **protected**。**protected** 也提供包访问权限，也就是说，相同包内的其他类可以访问 **protected** 元素。


​		
------------------------------------------------------------------------------------------------------------------

## 复用
	组合与继承
	你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。例如：
	class WaterSource {
  		private String s;

	}
	
	初始化的四种方法：
	
		1. 当对象被定义时。这意味着它们总是在调用构造函数之前初始化。
		2. 在该类的构造函数中。
		3. 在实际使用对象之前。这通常称为*延迟初始化*。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。
		4. 使用实例初始化。
		
		Bath.java重温初始化


​		
​		继承：OOP编程最具魅力的原因之一
​		
​			创建类时我们总是要继承，除了显示的继承之外，否则就隐士继承java的根类Object
​			继承语法采用extends ，java只支持单继承。
​			
​			初始化基类：
​				现在涉及到两个类:基类和派生类。创建派生类对象时，它将包括基类的子对象，这个子对象与创建的基类的子对象是一样的。必须正确初始化基类子对象，而且只有一种方法可以保证这一点：通过调用基类构造函数在构造函数中执行初始化。该构造函数具有执行基类初始化所需的所有适当信息和特权。Java 自动在派生类构造函数中插入对基类构造函数的调用。我们看实例：Cartoon.java
​		
​				带参数的构造函数：
​					编译器很容易调用这些构造函数，因为不需要参数。如果没有无参数的基类构造函数，或者必须调用具有参数的基类构造函数，则必须使用 **super** 关键字和适当的参数列表显式地编写对基类构造函数的调用:实例Chess.java


​		
​		
​		委托;
​			Java不直接支持的第三种重用关系称为委托。这介于继承和组合之间.
​			实例:Ship.java
​		
​		组合：
​			实例Car.java
​			
​		继承和组合的关系，继承是一种是一个，组合是一种有一个的关系。


​		
​		向上转型：继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系。简而言之，这种关系可以表述为“新类是已有类的一种类型”。
​			向上转型涉及到多态的编程思想，就像交通工具和汽车这两个类，汽车继承与交通工具，汽车可以有交通工具的相关属性和方法，于是这就意味着汽车也是交通工具的一种类型。实例：Wind.java
​			在实例Wind中tune方法接收一个instrument的引用，我们把wind类型的引用传入，代码对 **Instrument** 和 所有 **Instrument** 的派生类起作用，这种把 **Wind** 引用转换为 **Instrument** 引用的行为称作（向上转型）upcatsing
​		
​		再论组合和继承
​			在面向对象编程中，创建和使用代码最有可能的方法是将数据和方法一起打包到类中，然后使用该类的对象。也可以使用已有的类通过组合来创建新类。继承其实不太常用。因此尽管在教授 OOP 的过程中我们多次强调继承，但这并不意味着要尽可能使用它。恰恰相反，尽量少使用它，除非确实使用继承是有帮助的。一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。“多态”一章提出了一个使用向上转型的最有力的理由，但是只要记住问一问“我需要向上转型吗？”，就能在这两者中作出较好的选择。


​		
​	final关键字：final可能使用的地方：类，方法，调用
​	
​		final数据：许多编程语言都会有不变的常量，这种恒定值在许多方面都是极佳的选择方式如：
​				1.一个永不改变的编译时常量。
​				2.一个在运行时初始化就不会改变的值。
​			对于编译时常量这种情况，编译器可以把常量带入计算中；也就是说，可以在编译时计算，减少了一些运行时的负担。在 Java 中，这类常量必须是基本类型，而且用关键字 **final** 修饰。你必须在定义常量的时候进行赋值。
​			当final修饰引用类型时，该引用就恒定不变，这个引用就不能指向其他的对象。
​			
​		static和final的区别
​			final修饰的属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变。
​			static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变
​			static和“this、super”势不两立，static跟具体对象无关，而this、super正好跟具体对象有关。
​			static不可以修饰局部变量
​			
​			final static 同时使用时，会占用用静态存储区域的内存，且永不能被改变。
​			final修饰的基本数据类型变量，此区别只有当值在运行时被初始化时才会显现，因为编译器对编译时数值一视同仁
​			实例Value.java  博客https://www.cnblogs.com/HA-Tinker/p/10674226.html
​		
​		空白final
​			空白 final 指的是没有初始化值的 **final** 属性。编译器确保空白 final 在使用前必须被初始化。这样既能使一个类的每个对象的 **final** 属性值不同，也能保持它的不变性。
​		final参数
​			在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量
​				public class FinalArguments {
​				    void with(final Gizmo g) {
​				        //-g = new Gizmo(); // Illegal -- g is final
​				    }
​				    
​				    void without(Gizmo g) {
​				        g = new Gizmo(); // OK -- g is not final
​				        g.spin();
​				}
​		
​		final 方法
​			子类不可重写该方法，
​		final 和 private
​			类中所有的 **private** 方法都隐式地指定为 **final**。因为不能访问 **private** 方法，所以不能覆写它。
​			
​		final 类
​			当说一个类是 **final** （**final** 关键字在类定义之前），就意味着它不能被继承


​    
​    
​    
​    	类的初始化加载：
​    		在许多语言中，程序再启动的时候都要事先加载，然后初始化。必须仔细控制这些语言的初始化过程，以确保 **statics** 初始化的顺序不会造成麻烦。
​    		在java中万物皆对象，加载活动会轻松很多，java中每个类都是独立的文件，在要使用的时候，才会加载。一般可以说类的代码在首次使用时加载，这通常都是创建该类的对象的时候，或者是访问了static属性或者方法。当然，构造器也是一个static方法，准确的说一个类的static成员被访问时，类就会被加载。
​    		首次使用时就是 **static** 初始化发生时。所有的 **static** 对象和 **static** 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。**static** 变量只被初始化一次。


​    		
​    	继承于初始化：
​    		我们先从实例Beetle.java下手
​    		opps!  现在我们脑子应该很清楚了吧.


​    		
======================================================================================================================================


##多态
	
	忘掉对象类型
	Music.java
	当向上转型的时候，如果一个方法的参数为一个基类的引用，如果传递的子类的引用，就要为系统内重载不同的方法，这样就很不方便，于是多态就诞生了。
	
	但是有一个问题就是，父类引用作为参数，传递的确实派生类的引用，编译器如何知道基类引用指向派生类编译器无法得知。为了深入理解这个问题，有必要研究一下*绑定*这个主题。


​	
​	方法调用绑定：
​		将一个方法调用和一个方法主体关联起来称作*绑定*。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做*前期绑定*。将一个方法调用和一个方法主体关联起来称作*绑定*。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做*前期绑定*。
​		编译器只知道一个父类的引用，他无法知道会调用那个方法！
​		
​		后期绑定：
​			意味着在运行时根据对象的类型进行绑定。后期绑定也称为*动态绑定*或*运行时绑定*。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息。


			！！Java 中除了 **static** 和 **final** 方法（**private** 方法也是隐式的 **final**）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。
			
			final可以方式方法重写，它有效的关闭动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 **final** 方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 **final**，而不是为了提升性能而使用。
			https://www.cnblogs.com/moxiaotao/p/10149258.html 博客


​			
​		向上转型的疑惑
​		Shape.java 一系列的类 main方法中包含一个shapes数组的引用，每个元素都是随机的，随机生成形状更好的说明了，编译期间，编译器不知道任何具体的信息，所有的方法都是动态绑定的。
​	
​	多态的可扩展性：
​		由于多态机制，你可以向系统中添加任意多的新类型，而不需要修改 `tune()` 方法。在一个设计良好的面向对象程序中，许多方法将会遵循 `tune()` 的模型，只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类派生出新的数据类型，从而添加新的功能。那些操纵基类接口的方法不需要改动就可以应用于新类。		


​	
​	
​	陷阱：“重写”私有方法
​		Derived.java
​	陷阱：属性和静态方法
​		Super.java Sub.java  
​		当 **Sub** 对象向上转型为 **Super** 引用时，任何属性访问都被编译器解析，因此不是多态的。在这个例子中，**Super.field** 和 **Sub.field** 被分配了不同的存储空间，因此，**Sub** 实际上包含了两个称为 **field** 的属性：它自己的和来自 **Super** 的。然而，在引用 **Sub** 的 **field** 时，默认的 **field** 属性并不是 **Super** 版本的 **field** 属性。为了获取 **Super** 的 **field** 属性，需要显式地指明 **super.field**。
​		
​		静态的方法只与类关联，与单个的对象无关。


​		
​	构造器和多态
​		构造器都是隐士的static，所以不具备多态的性质
​		
​		再叙构造器调用顺序：在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用。这么做是有意义的，因为构造器需要检查对象是否被正确的构造。由于属性通常声明为 **private**，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。因此，必须得调用所有构造器；否则就不能构造完整的对象。这就是编译器强制每个派生类部分必须调用构造器的原因。如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。	
​		
​		下面展示一个实例Sandwich.java
​		从创建 **Sandwich** 对象的输出中可以看出对象的构造器调用顺序如下：
​	
​			1. 基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类。
​			2. 按声明顺序初始化成员。
​			3. 调用派生类构造器的方法体。
​		构造器的调用顺序很重要。当使用继承时，就已经知道了基类的一切，并可以访问基类中任意 **public** 和 **protected** 的成员。
​		
​		如果遵循这条实践，就可以帮助确保所有的基类成员和当前对象的成员对象都已经初始化。


​		
​	继承和清理
​		在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃圾收集器处理。如果你存在清理问题，那么必须用心地为新类创建一个 `dispose()` 方法（这里用的是我选择的名称，你可以使用更好的名称）。由于继承，如果有其他特殊的清理工作的话，就必须在派生类中重写 `dispose()` 方法。当重写 `dispose()` 方法时，记得调用基类的 `dispose()` 方法，否则基类的清理工作不会发生
​		
​		首先进行派生类的清理工作，然后才是基类的清理。这是因为派生类的清理可能调用基类的一些方法，所以基类组件这时得存活，不能过早地被销毁。输出显示了，**Frog** 对象的所有部分都是按照创建的逆序销毁的。


​	
​	
​	构造器内部多态方法的行为
​		构造器调用的层次结构带来了一个困境。如果在构造器中调用了正在构造的对象的动态绑定方法，会发生什么呢？！！！！！！！
​		Glyph.java
​		在普通的方法中，动态绑定的调用是在运行时解析的，因为对象不知道它属于方法所在的类还是类的派生类。
​	
​		如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些 bug 很隐蔽，难以发现。
​		从概念上讲，构造器的工作就是创建对象（这并非是平常的工作）。在构造器内部，整个对象可能只是部分形成——只知道基类对象已经初始化。如果构造器只是构造对象过程中的一个步骤，且构造的对象所属的类是从构造器所属的类派生出的，那么派生部分在当前构造器被调用时还没有初始化。然而，一个动态绑定的方法调用向外深入到继承层次结构中，它可以调用派生类的方法。如果你在构造器中这么做，就可能调用一个方法，该方法操纵的成员可能还没有初始化——这肯定会带来灾难。
​		
​		前一小节描述的初始化顺序并不十分完整，而这正是解决谜团的关键所在。初始化的实际过程是：
​	
​			1. 在所有事发生前，分配给对象的存储空间会被初始化为二进制 0。
​			2. 如前所述调用基类构造器。此时调用重写后的 `draw()` 方法（是的，在调用 **RoundGraph** 构造器之前调用），由步骤 1 可知，**radius** 的值为 0。
​			3. 按声明顺序初始化成员。
​			4. 最终调用派生类的构造器。
​		编写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的 **final** 方法（这也适用于可被看作是 **final** 的 **private** 方法）。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。


​		
​		继承设计：更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行为），而继承要求必须在编译时知道确切类型。
​		`
​		class Actor {
​		    public void act() {}
​		}
​		
​		class HappyActor extends Actor {
​		    @Override
​		    public void act() {
​		        System.out.println("HappyActor");
​		    }
​		}
​		
​		class SadActor extends Actor {
​		    @Override
​		    public void act() {
​		        System.out.println("SadActor");
​		    }
​		}
​		
​		class Stage {
​		    private Actor actor = new HappyActor();
​		    
​		    public void change() {
​		        actor = new SadActor();
​		    }
​		    
​		    public void performPlay() {
​		        actor.act();
​		    }
​		}
​		
​		public class Transmogrify {
​		    public static void main(String[] args) {
​		        Stage stage = new Stage();
​		        stage.performPlay();
​		        stage.change();
​		        stage.performPlay();
​		    }
​		}
​		
​		`
​		
​			在上述的代码中Stage对象包含了actor引用，初始化被指向一个happyactor但是既然引用可以在运行时与其他不同的对象绑定，那么它就可以被替换成对 **SadActor** 的引用，`performPlay()` 的行为随之改变。这种运行时的灵活性被称为状态模式

======================================================================================================================================

## 接口

	接口的作用就是通过通用接口操作一系列的类，接口不是具体的实现，所以创建接口类毫无意义。子类可以以不同的方式来实现接口通用接口建立了一个基本形式，以此表达所有派生类的共同部分。另一种说法把称为抽象基类，或简称抽象类。
	
	抽象方法：没有方法体
		abstract void fun();
		包含抽象方法的类叫做*抽象类*。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。


​	
​	可以将一个不包含任何抽象方法的类指明为 **abstract**，在类中的抽象方法没啥意义但想阻止创建类的对象时，这么做就很有用。
​	
​	为了创建可初始化的类，就要继承抽象类，并提供所有抽象的定义：
​		abstract class Uninstantiable {
​		    abstract void f();
​		    abstract int g();
​		}
​	
​		public class Instantiable extends Uninstantiable {
​		    @Override
​		    void f() {
​		        System.out.println("f()");
​		    }
​		    
​		    @Override
​		    int g() {
​		        return 22;
​		    }
​		    
​		    public static void main(String[] args) {
​		        Uninstantiable ui = new Instantiable();
​		    }
​		}


​		
​			private abstract 被禁止是有意义的，因为你不可能在任何子类合法的定义它。
​			
​			抽象类的子类是可以创建对象的，子类可以定义为抽象类，也可以不定义。
​			Demo01.java


​			
​			
​		接口：
​			接口中，我们不用在方法前加上abstract，在java中知道这些方法不能有方法体。
​			一个接口表示：所有实现了该接口的类看起来都像这样。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。所以，接口被用来建立类之间的协议。（一些面向对象编程语言中，使用 protocol 关键字完成相同的功能。）
​			Java8做了一些变化，因为Java8包含默认方法和静态方法。接口的典型使用是代表一个类的类型或一个形容词，如 Runnable 或 Serializable
​			接口同样可以包含属性，这些属性被隐式指明为 **static** 和 **final**。
​			接口中方法默认都是public
​			
​			默认方法：
​				当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 **default** 创建的方法体。默认方法比抽象类中的方法受到更多的限制，但是非常有用，我们将在“流式编程”一章中看到。
​				default方法在java8之前都被禁止。这是个极佳的选择。请参阅Ainterface.java


​				
​			多继承：多继承意味着一个类可能从多个父类型中继承特征和特性。
​			Java 过去是一种严格要求单继承的语言：只能继承自一个类（或抽象类），但可以实现任意多个接口。在 Java 8 之前，接口没有包袱——它只是方法外貌的描述。
​			多年后的现在，Java 通过默认方法具有了某种多继承的特性。结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性（只有静态属性，不适用），所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承。
​			
​			接口中的静态方法：Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具。
​				工具功能置于接口之中！!
​				Instrument.java
​			|         特性         |                            接口                            |                  抽象类                  |
​			
​			|         组合         |                    新类可以组合多个接口                    |          只能继承单一抽象类     |
​			|         状态         |        不能包含属性（除了静态属性，不支持对象状态）        | 可以包含属性，非抽象方法可能引用这些属性 |
​			| 默认方法 和 抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 |  必须在子类中实现抽象方法         |
​			|        构造器        |                         没有构造器                         |               可以有构造器               |
​			|        可见性        |                      隐式 **public**      |       可以是 **protected** 或友元        |
​				
​		完全解耦：
​			当方法操纵的是一个类而非接口时，它就只能作用于那个类或其子类。如果想把方法应用于那个继承层级结构之外的类，就会触霉头。接口在很大程度上放宽了这个限制，因而使用接口可以编写复用性更好的代码。
​			从Applicator.java开始
​			假设有一个Filter类 详见Filter.java
​			**Filter** 类与 **Processor** 类具有相同的接口元素，但是因为它不是继承自 **Processor** —— 因为 **Filter** 类的创建者根本不知道你想将它当作 **Processor** 使用 —— 因此你不能将 **Applicator** 的 `apply()` 方法应用在 **Filter** 类上，即使这样做也能正常运行。主要是因为 **Applicator** 的 `apply()` 方法和 **Processor** 过于耦合，这阻止了 **Applicator** 的 `apply()` 方法被复用。另外要注意的一点是 Filter 类中 `process()` 方法的输入输出都是 **Waveform**。
​			
​			但是，若把Processor 设计为一个接口，那么限制就会变得松动到足以复用 **Applicator** 的 `apply()` 方法，用来接受那个接口参数。
​			这种方式运作得很好，然而你经常遇到的情况是无法修改类。例如在电子滤波器的例子中，类库是被发现而不是创建的。在这些情况下，可以使用*适配器*设计模式。
​			FilterAdapter.java
​		
​		多接口结合：
​			接口没有任何实现——也就是说，没有任何与接口相关的存储——因此无法阻止结合的多接口。这是有价值的，因为你有时需要表示“一个 **x** 是一个 **a** 和一个 **b** 以及一个 **c**”。
​			
​			使用继承扩展接口
​		
​			结合接口时的命名冲突：
​				Conflict.java
​				
​		接口适配：
​			接口最吸引人的原因之一是相同的接口可以有多个实现。在简单情况下体现在一个方法接受接口作为参数，该接口的实现和传递对象给方法则交由你来做。
​			因此，接口的一种常见用法是前面提到的*策略*设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法” ，这使得方法更加灵活，通用，并更具可复用性。
​			
​			类 **Scanner** 的构造器接受的是一个 **Readable** 接口（在“字符串”一章中学习更多相关内容）。你会发现 **Readable** 没有用作 Java 标准库中其他任何方法的参数——它是单独为 **Scanner** 创建的，因此 **Scanner** 没有将其参数限制为某个特定类。通过这种方式，**Scanner** 可以与更多的类型协作。如果你创建了一个新类并想让 **Scanner** 作用于它，就让它实现 **Readable** 接口
​			RandomStrings.java
​			
​		接口字段
​			因为接口中的字段都自动是 **static** 和 **final** 的，所以接口就成为了创建一组常量的方便的工具。

===================================================================================================================

##内部类
	>
	一个定义在另一个类中的类，叫作内部类。
	
	内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。然而必须要了解，内部类与组合是完全不同的概念，这一点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是这样（而且 Java 8 的 Lambda 表达式和方法引用减少了编写内部类的需求）。最初，内部类可能看起来有些奇怪，而且要花些时间才能在设计中轻松地使用它们。对内部类的需求并非总是很明显的，但是在描述完内部类的基本语法与语义之后，"Why inner classes?"就应该使得内部类的益处明确显现了。
	
	-创建内部类:
		Parcel1.java
		如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在 `main()` 方法中那样，具体地指明这个对象的类型：*OuterClassName.InnerClassName*。
	
	-链接外部类：
		内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的外围对象（enclosing object）之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。
			interface Selector {
			    boolean end();
			    Object current();
			    void next();
			}
			public class Sequence {
			    private Object[] items;
			    private int next = 0;
			    public Sequence(int size) {
			        items = new Object[size];
			    }
			    public void add(Object x) {
			        if(next < items.length)
			            items[next++] = x;
			    }
			    private class SequenceSelector implements Selector {
			        private int i = 0;
			        @Override
			        public boolean end() { return i == items.length; }
			        @Override
			        public Object current() { return items[i]; }
			        @Override
			        public void next() { if(i < items.length) i++; }
			    }
			    public Selector selector() {
			        return new SequenceSelector();
			    }
			    public static void main(String[] args) {
			        Sequence sequence = new Sequence(10);
			        for(int i = 0; i < 10; i++)
			            sequence.add(Integer.toString(i));
			        Selector selector = sequence.selector();
			        while(!selector.end()) {
			            System.out.print(selector.current() + " ");
			            selector.next();
			        }
			    }
			}
		
		sequence只是固定了一个大小的object数组，以类的形式包装起来，而方法的具体实现全部放到了内部类中，内部类可以直接方法外部类的所有成员和方法.可以使用 **Selector** 接口。这是“迭代器”设计模式的一个例子，在本书稍后的部分将更多地学习它.
		最初看到 **SequenceSelector**，可能会觉得它只不过是另一个内部类罢了。但请仔细观察它，注意方法 `end()`，`current()` 和 `next()` 都用到了 **items**，这是一个引用，它并不是 **SequenceSelector** 的一部分，而是外围类中的一个 **private** 字段。然而内部类可以访问其外围类的方法和字段，就像自己拥有它们似的，这带来了很大的方便，就如前面的例子所示。
		
		所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？
			内部类对象会秘密捕获一个指向那个外围类对象的引用。在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。


​		.this和.new
​			如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 **this**。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。
​			参阅DotThis.java
​			
​			当有一个外部类包含了某个内部类，若是我们想创建内部类的实例，这里就要使用到.new语法，要想直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字 **DotNew**，而是必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的那样。


​		
​		-内部类和向上转型(so funny！！！)
​			当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类-某个接口的实现-能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。
​			参阅Test.java
​			在test.java中内部类Pcontent是私有的。
​			**private** 内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给 Java 编译器提供了生成高效代码的机会。


​			
​		-内部类方法和作用域
​			通常，如果所读、写的代码包含了内部类，那么它们都是“平凡的”内部类，简单并且容易理解。然而，内部类的语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。
​			这么做有两个理由：
​	
​			1. 如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。
​			2. 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。
​			
​			以下包括的内部类：
​				1.定义在方法的内部类
​				2.一个定义在作用域内的类，此作用域在方法的内部。
​				3.一个实现接口的内部类
​				4.匿名类，扩展了没有默认构造器的类
​				5.匿名类执行初始化字段
​				6.匿名类，实例化初始化实现构造(匿名类内不能有构造器)


​				
​				一。定义在方法内的内部类(作局部内部类)
​					Parce2.java
​				二。匿名内部类
​					Perce3.java
​					另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个 **Contents** 对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义。
​				这种奇怪的语法指的是：“创建一个继承自 Contents的匿名类的对象。”通过 new表达式返回的引用被自动向上转型为对 Contents 的引用。上述匿名内部类的语法是下述形式的简化形式：
​				public class Parcel7b {
​			    class MyContents implements Contents {
​			        private int i = 11;
​			        @Override
​			        public int value() { return i; }
​			    }
​			  
​			    public Contents contents() {
​			        return new MyContents();
​			    }
​			  
​			    public static void main(String[] args) {
​			        Parcel7b p = new Parcel7b();
​			        Contents c = p.contents();
​			    }
​			}
​				这个匿名内部类中，使用了默认的构造器来生成 **Contents**。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：Parce4.java
​				
​				如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是 **final** 的（也就是说，它在初始化后不会改变，所以可以被当作 **final**），就像你在 `destination()` 的参数中看到的那样。这里省略掉 **final** 也没问题，但是通常最好加上 **final** 作为一种暗示。
​				Parce5.java
​				如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：
​				Parce6.java
​				
​		在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是 **if** 语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。
​		
​		-嵌套类
​			如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为 **static**，这通常称为嵌套类。想要理解 **static** 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是 **static** 的时，就不是这样了。嵌套类意味着：
​				
​				1. 要创建嵌套类的对象，并不需要其外围类的对象。
​				2. 不能从嵌套类的对象中访问非静态的外围类对象。
​			嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 **static** 数据和 **static** 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：


​		
​		-接口内部的类
​			嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是 **public** 和 **static** 的。因为类是 **static** 的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外围接口
​			public interface ClassInInterface {
​		    void howdy();
​		    class Test implements ClassInInterface {
​		        @Override
​		        public void howdy() {
​		            System.out.println("Howdy!");
​		        }
​		        public static void main(String[] args) {
​		            new Test().howdy();
​		        }
​		    }
​		}
​		如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。


​		
​		-从多层嵌套类中访问外部类的成员
​			一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外围类的所有成员
​			
​		-为什么需要内部类
​			一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。
​			
​			-内部类和外部类实现一个接口有什么区别？
​				后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：
​	
​			> 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
​	
​			如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类）。为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类：
​			MultiInterfaces.java
​			如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承,因为抽象类是不可以new的。
​			
​			如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：
​			1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立
​			2.在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
​			3.创建内部类对象的时刻并不依赖于外围类对象的创建
​			4.内部类并没有令人迷惑的"is-a”关系，它就是一个独立的实体
​			
​		-闭包与回调
​			闭包（**closure**）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 **private** 成员。在 Java 8 之前，生成闭包行为的唯一方式就是内部类。在 Java 8 之后，我们可以使用 lambda  表达式来生成闭包行为，并且语法更加精细和简洁；你将会在 [函数式编程 ]() 这一章节中学习相关细节。即使应该优先使用 lambda 表达式用于内部类闭包，你依旧会看到那些 Java 8 以前的代码，即使用内部类来表示闭包的方式，所以非常有必要来理解这种形式。
​			Java 最引人争议的问题之一就是，人们认为 Java 应该包含某种类似指针的机制，以允许回调（callback）。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java 更小心仔细，所以没有在语言中包括指针。
​			Callbacks.java
​			
​			总结：在Callbacks.java 外围类实现一个接口与内部类实现此接口之间的区别，就代码而言，**Callee1** 是更简单的解决方式。**Callee2** 继承自 **MyIncrement**，后者已经有了一个不同的 `increment()` 方法，并且与 **Incrementable** 接口期望的 `increment()` 方法完全不相关。所以如果 **Callee2** 继承了 **MyIncrement**，就不能为了 **Incrementable** 的用途而覆盖 `increment()` 方法，于是只能使用内部类独立地实现 **Incrementable**，还要注意，当创建了一个内部类时，并没有在外围类的接口中添加东西，也没有修改外围类的接口。
​			Callee2中除了`getCallbackReference()` 以外，其他成员都是 **private** 的。这里可以看到interface是如何允许接口和接口实现完全独立的。内部类实现了该接口，并返回了一个hook钩子，而且是安全的钩子，无论谁获得此 **Incrementable** 的引用，都只能调用 `increment()`，除此之外没有其他功能（不像指针那样，允许你做很多事情）。
​			回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。例如，在图形界面实现 GUI 功能的时候，到处都用到回调。


​			
​		-内部类与控制框架
​			介绍的控制框架（control framework）中，可以看到更多使用内部类的具体例子。
​			应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题。这是设计模式中模板方法的一个例子，模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。
​			控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作*事件驱动*系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统。
​			要理解内部类是如何允许简单的创建过程以及如何使用控制框架的，请考虑这样一个控制框架，它的工作就是在事件“就绪”的时候执行事件。虽然“就绪”可以指任何事，但在本例中是指基于时间触发的事件。接下来的问题就是，对于要控制什么，控制框架并不包含任何具体的信息。那些信息是在实现算法的 `action()` 部分时，通过继承来提供的。
​	
​			首先，接口描述了要控制的事件。因为其默认的行为是基于时间去执行控制，所以使用抽象类代替实际的接口.
​			Event.java
​			下面的文件包含了一个用来管理并触发事件的实际控制框架。**Event** 对象被保存在 **List**\<**Event**\> 类型（读作“Event 的列表”）的容器对象中，容器会在 [集合 ]() 中详细介绍。目前读者只需要知道 `add()` 方法用来将一个 **Event** 添加到 **List** 的尾端，`size()` 方法用来得到 **List** 中元素的个数，foreach 语法用来连续获联 **List** 中的 **Event**，`remove()` 方法用来从 **List** 中移除指定的 **Event**。
​			Controller.java
​			`run()` 方法循环遍历 **eventList**，寻找就绪的（`ready()`）、要运行的 **Event** 对象。对找到的每一个就绪的（`ready()`）事件，使用对象的 `toString()` 打印其信息，调用其 `action()` 方法，然后从列表中移除此 **Event**。
​	
​			注意，在目前的设计中你并不知道 **Event** 到底做了什么。这正是此设计的关键所在—"使变化的事物与不变的事物相互分离”。用我的话说，“变化向量”就是各种不同的 **Event** 对象所具有的不同行为，而你通过创建不同的 **Event** 子类来表现不同的行为。
​			
​			$$使变化的事物和不变的事物互相分离$$
​			这正是内部类要做的事情，内部类允许：
​	
​				1. 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的 `action()`。
​				2. 内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。
​				
​			考虑此控制框架的一个特定实现，如控制温室的运作：控制灯光、水、温度调节器的开关，以及响铃和重新启动系统，每个行为都是完全不同的。控制框架的设计使得分离这些不同的代码变得非常容易。使用内部类，可以在单一的类里面产生对同一个基类 **Event** 的多种派生版本。对于温室系统的每一种行为，都继承创建一个新的 **Event** 内部类，并在要实现的 `action()` 中编写控制代码。
​			GreenhouseControls.java 精读


​		-继承内部类
​			因为内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，事情会变得有点复杂。问题在于，那个指向外围类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联
​			
​			class WithInner {
​			class Inner {}
​		}
​		public class InheritInner extends WithInner.Inner {
​		    //- InheritInner() {} // Won't compile 不会编译
​		    InheritInner(WithInner wi) {
​		        wi.super();
​		    }
​		    public static void main(String[] args) {
​		        WithInner wi = new WithInner();
​		        InheritInner ii = new InheritInner(wi);
​		    }
​		}


​		
​		
​		-内部类可以被覆盖么？
​			如果创建了一个内部类，然后继承其外围类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被覆盖吗？这看起来似乎是个很有用的思想，但是“覆盖”内部类就好像它是外围类的一个方法，其实并不起什么作用，这个例子说明，当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的


​			
​		
​		-局部内部类
​			方法里面创建类


​		
​		-内部类标识符
​			由于编译后每个类都会产生一个**.class** 文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个"meta-class"，叫做 **Class** 对象）。
​			Counter.class
​			LocalInnerClass$1.class
​			LocalInnerClass$LocalCounter.class
​			LocalInnerClass.class



=============================================================================================================

## 集合




	-泛型和类型安全的集合
		使用java5之前的集合的一个主要问题是编译器允许你向集合中插入不正确的类型，只会抛出运行时异常。
		通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。这样编写程序就方便了很多
		
	-基本概念
		**集合（Collection）** ：一个独立元素的序列，这些元素都服从一条或多条规则。**List** 必须以插入的顺序保存元素， **Set** 不能包含重复元素， **Queue** 按照*排队规则*来确定对象产生的顺序（通常与它们被插入的顺序相同）。
		**映射（Map）** ： 一组成对的“键值对”对象，允许使用键来查找值。 **ArrayList** 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。  **map** 允许我们使用一个对象来查找另一个对象，它也被称作*关联数组*（associative array），因为它将对象和其它对象关联在一起；或者称作*字典*（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 **Map** 是强大的编程工具。
		//创建一个list集合 List<Apple> list = new List<>();
		
		**Collection**  接口概括了*序列*的概念——一种存放一组对象的方式。



	-列表List
		列表有两种类型：1.基本的ArrayList 2.LinkedList

​	**添加元素组** 

>util包中的Arrays和Collections类中都有很多实用的方法`Arrays.asList()` ，`Collections.addAll()`

**集合的打印**

>直接打印集合对象的引用，会使用tostring方法
>
>List: **Linkedlist** , **Arraylist**
>Set: **HashSet** ， **TreeSet** 和 **LinkedHashSet** 
>Map:**HashMap** ， **TreeMap** 和 **LinkedHashMap** 

**列表List**

>有两种类型的 **List** ：
>
>- 基本的 **ArrayList** ，擅长随机访问元素，但在 **List** 中间插入和删除元素时速度较慢。本质数组
>- **LinkedList** ，它通过代价较低的在 **List** 中间进行的插入和删除操作，提供了优化的顺序访问。 **LinkedList** 对于随机访问来说相对较慢，但它具有比 **ArrayList** 更大的特征集。链表

**迭代器**

>*迭代器*（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为*轻量级对象*（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。
>
>迭代器只能用来：
>
>1. 使用iterator() 方法返回一个集合的迭代器
>2. next 返回下一个集合元素
>3. hasnext判断是否还有下一个元素
>4. remove将迭代器最近返回的那个元素删除
>
>**ListIterator** 迭代器
>是一个更强大的 **Iterator** 子类型，它只能由各种 **List** 类生成。 **Iterator** 只能向前移动，而 **ListIterator** 可以双向移动。它还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 `set()` 方法替换它访问过的最近一个元素。可以通过调用 `listIterator()` 方法来生成指向 **List** 开头处的 **ListIterator** ，还可以通过调用 `listIterator(n)` 创建一个一开始就指向列表索引号为 **n** 的元素处的 **ListIterator** 。 

**链表**

**LinkedList** 也像 **ArrayList** 一样实现了基本的 **List** 接口，但它在 **List** 中间执行插入和删除操作时比 **ArrayList** 更高效。然而,它在随机访问操作效率方面却要逊色一些。
**LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）** 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 **Queue** 中）



**堆栈**

>Java 1.0 中附带了一个 **Stack** 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 **ArrayDeque**

**集合**（Set）

**Set** 不保存重复的元素。 如果试图将相同对象的多个实例添加到 **Set** 中，那么它会阻止这种重复行为。  **Set** 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 **Set** 中。因此，查找通常是 **Set** 最重要的操作，因此通常会选择 **HashSet** 实现，该实现针对快速查找进行了优化。

**Set** 具有与 **Collection** 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 **List** 那样。实际上， **Set** 就是一个 **Collection**  ，只是行为不同。

>```java
>import java.util.*;
>
>public class SetOfInteger {
>  public static void main(String[] args) {
>    Random rand = new Random(47);
>    Set<Integer> intset = new HashSet<>();
>    for(int i = 0; i < 10000; i++)
>      intset.add(rand.nextInt(30));
>    System.out.println(intset);
>  }
>}
>```
>
>//由 **HashSet** 维护的顺序与 **TreeSet** 或 **LinkedHashSet** 不同，因为它们的实现具有不同的元素存储方式。 **TreeSet** 将元素存储在红-黑树数据结构中，而 **HashSet** 使用散列函数。  **LinkedHashSet** 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。看起来散列算法好像已经改变了，现在 **Integer** 按顺序排序。
>
>如果对象需要排序，可以使用TreeSet而不是HashSet

**Map** 

>自动包装机制将随机生成的 **int** 转换为可以与 **HashMap** 一起使用的 **Integer** 引用（不能使用基本类型的集合）。如果键不在集合中则 `get()` 返回 **null** （这意味着该数字第一次出现）。否则， `get()` 会为键生成与之关联的 **Integer** 值，然后该值被递增（自动包装机制再次简化了表达式，但实际上确实发生了对 **Integer** 的装箱和拆箱）。

**队列**

队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在[并发编程]()中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。

**LinkedList** 实现了 **Queue** 接口，并且提供了一些方法以支持队列行为，因此 **LinkedList** 可以用作 **Queue** 的一种实现。 通过将 **LinkedList** 向上转换为 **Queue** 

**优先队列 PriorityQueue**

先进先出（FIFO）描述了最典型的*队列规则*（queuing discipline）。队列规则是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个弹出的元素应该是等待时间最长的元素。优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。例如，在机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息传递系统，某些消息比其他消息更重要，应该尽快处理，而不管它们何时到达。在Java 5 中添加了 **PriorityQueue** ，以便自动实现这种行为。当在 **PriorityQueue** 上调用 `offer()` 方法来插入一个对象时，该对象会在队列中被排序。[^5]默认的排序使用队列中对象的*自然顺序*（natural order），但是可以通过提供自己的 **Comparator** 来修改这个顺序。 **PriorityQueue** 确保在调用 `peek()` ， `poll()` 或 `remove()` 方法时，获得的元素将是队列中优先级最高的元素。

**集合和迭代器**

>**Collection** 是所有序列集合共有的根接口





===========================================================================================

# 函数式编程

函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。

计算机早期编程采用汇编的技术，编译的代码比手工的代码要多很多字节，为了程序适合有限的内存，程序员会修改内存的代码，来充分利用资源，这中技术叫做自修改代码。随着硬件越来越便宜，程序的规模和复杂性都在增长。这一切只是让程序工作变得困难。我们想方设法使代码更加一致和易懂。使用纯粹的自修改代码造成的结果就是：我们很难确定程序在做什么。它也难以测试。所以，使用代码以某种方式操作其他代码的想法十分有趣，只要保证它足够安全。从代码创建，维护和可靠性的角度来看，这个想法非常吸引人。我们可以重用代码，降低维护的成本，并且可以重复理解代码，测试代码，最后组合为一个程序。

作者就是函数式编程(FP)的意思之所在。

纯粹的函数是语言在安全性上更近一步，它加强了额外的约束，就是数据是不可以改变的；设置一次，永久不变。将该值传递给函数作为参数，该函数然后生成新值但从不修改自身外部的任何东西（包括其参数或该函数范围之外的元素）。
函数仅创造并返回结果，不会出现错误。
这种不可变对象和无副作用成为了并发编程的得力助手。这种问题就在于共享数据问题，这意味着代码的不同部分，在不同的处理器上运行可以尝试修改同一块内存的数据，如果函数永远不会修改现有值，只会催生出新的值，则不会对内存产生争用，这就是纯粹函数式语言的定义。



**新旧对比**

>在接口的学习中，通过定义接口方法，不同的类可以实现不同的行为。如果我们希望方法在调用时行为不同，只要将代码传递给方法，我们就可以控制它的行为。此前，我们在方法在包含所需行为的对象，就可以实现不同的行为，下面我们用传统形式和 Java 8 的方法引用、Lambda 表达式分别演示。

```java
interface Strategy {
  String approach(String msg);
}

class Soft implements Strategy {
  public String approach(String msg) {
    return msg.toLowerCase() + "?";
  }
}

class Unrelated {
  static String twice(String msg) {
    return msg + " " + msg;
  }
}

public class Strategize {
  Strategy strategy;//包含接口对象的引用，来实现行为的不同
  String msg;
  Strategize(String msg) {
    strategy = new Soft(); // [1] 接口指向实现类，传统形式
    this.msg = msg;
  }

  void communicate() {
    System.out.println(strategy.approach(msg));//实现不同的行为，典型的封装隐藏！
  }

  void changeStrategy(Strategy strategy) {
      //我们通过改变不同的对象引用来改变不同的行为
    this.strategy = strategy;
  }

  public static void main(String[] args) {
      //主函数入口
    Strategy[] strategies = {
      new Strategy() { // [2]
        public String approach(String msg) {
          return msg.toUpperCase() + "!";
        }
          //匿名内部类
      },
      msg -> msg.substring(0, 5), // [3]lambda表达式
      Unrelated::twice // [4]java8方法引用
    };//匿名内部类数组
    Strategize s = new Strategize("Hello there");
    s.communicate();
    for(Strategy newStrategy : strategies) {
      s.changeStrategy(newStrategy); // [5]
      s.communicate(); // [6]
    }
  }
}

//
-1.传统上，我们使用接口指向实现类来实现不同的行为。在Strategize 我们使用构造器默认使用Soft，并且可以使用匿名内部类来简化代码。 
-2.Java 8 的 Lambda 表达式。由箭头 `->` 分隔开参数和函数体，箭头左边是参数，箭头右侧是从 Lambda 返回的表达式，即函数体。这实现了与定义类、匿名内部类相同的效果，但代码少得多。
-3.Java 8 的**方法引用**，由 `::` 区分。在 `::` 的左边是类或对象的名称，在 `::` 的右边是方法的名称，但没有参数列表。
    在 Java 8 之前，我们能够通过 **[1]** 和 **[2]** 的方式传递功能。然而，这种语法的读写非常笨拙，并且我们别无选择。方法引用和 Lambda 表达式的出现让我们可以在需要时**传递功能**，而不是仅在必要才这么做。
```



**Lambda表达式**

>https://www.cnblogs.com/CarpenterLee/p/5978721.html
>https://www.cnblogs.com/CarpenterLee/p/6507161.html
>[https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/2-Lambda%20and%20Anonymous%20Classes(II).md](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/2-Lambda and Anonymous Classes(II).md)
>http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html
>
>Lambda 表达式是使用**最小可能**语法编写的函数定义：
>
>1. Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。
>
>2. Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。
>
>lambda表达式语法格式：
>
>1. 参数。
>2. 接着 `->`，可视为“产出”。
>3. `->` 之后的内容都是方法体。
>
>**[1]** 当只用一个参数，可以不需要括号 `()`。 然而，这是一个特例。
>**[2]** 正常情况使用括号 `()` 包裹参数。 为了保持一致性，也可以使用括号 `()` 包裹单个参数，虽然这种情况并不常见。
>**[3]** 如果没有参数，则必须使用括号 `()` 表示空参数列表。
>**[4]** 对于多个参数，将参数列表放在括号 `()` 中。
>
>到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 **return** 关键字是非法的。 这是 Lambda 表达式缩写用于描述功能的语法的另一种方式。
>
>**[5]** 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 **return**。
>
>Lambda 表达式通常比**匿名内部类**产生更易读的代码.



**递归**

可以编写递归的 Lambda 表达式，但需要注意：递归方法必须是实例变量或静态变量，否则会出现编译时错误。 



**方法引用**

Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 `::` [^4]，然后跟方法名称。

```JAVA
import java.util.*;

interface Callable { // [1]
  void call(String s);
}//接口

class Describe {
  void show(String msg) { // [2]
    System.out.println(msg);
  }
}//Describe 类

public class MethodReferences {
  static void hello(String name) { // [3]
    System.out.println("Hello, " + name);
  }
    //静态函数
    //静态的内部类
  static class Description {
    String about;
    Description(String desc) { about = desc; }//初始化成员变量
    void help(String msg) { // [4]
      System.out.println(about + " " + msg);
    }
  }
  static class Helper {
    static void assist(String msg) { // [5]
      System.out.println(msg);
    }
  }//静态内部类，完全属于外部类本身，不属于外部类某一个对象
    /*
    如何创建静态内部类实例

　　　1）在非外部类中：外部类名.内部类名 name = new 外部类名.内部类名();

　　　2）在外部类中：内部类名 name = new 内部类名();

 
    */
  public static void main(String[] args) {
    Describe d = new Describe();
    Callable c = d::show; // [6]
    c.call("call()"); // [7]

    c = MethodReferences::hello; // [8]
    c.call("Bob");

    c = new Description("valuable")::help; // [9]
    c.call("information");

    c = Helper::assist; // [10]
    c.call("Help!");
  }
}

//输出结果
call()
Hello, Bob
valuable information
Help!
    
   
```

**[1]** 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。
**[2]** `show()` 的签名（参数类型和返回类型）符合 **Callable** 的 `call()` 的签名。

**[3]** `hello()` 也符合 `call()` 的签名。 

**[4]**  `help()` 也符合，它是静态内部类中的非静态方法。

**[5]** `assist()` 是静态内部类中的静态方法。

**[6]** 我们将 **Describe** 对象的方法引用赋值给 **Callable** ，它没有 `show()` 方法，而是 `call()` 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 **Callable** 的 `call()` 方法的签名。

**[7]** 我们现在可以通过调用 `call()` 来调用 `show()`，因为 Java 将 `call()` 映射到 `show()`。

**[8]** 这是一个**静态**方法引用。

**[9]** 这是 **[6]** 的另一个版本：对已实例化对象的方法的引用，有时称为*绑定方法引用*。

**[10]** 最后，获取静态内部类的方法引用的操作与 **[8]** 中外部类方式一样。



**Runnable接口**

```java
public class Demo07 {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("hello");
            }
        }).start();
        new Thread(
                ()->System.out.println("Java")
        ).start();
    }
}
```



**Thread** 对象将 **Runnable** 作为其构造函数参数，并具有会调用 `run()` 的方法  `start()`。 **注意**，只有**匿名内部类**才需要具有名为 `run()` 的方法。



**未绑定的方法引用**

未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象

```java
	//未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象

package 函数式编程;
class X{
   static String f(){return "X::f()";};
}
interface  MakeString {
    String make();
}
interface  Transform{
    String transform(X x);
}
public class Demo09  {
    public static void main(String[] args) {
        MakeString mk = X::f;//当我们给f()加上static这个就可行，首先说说方法引用，因为签名一样，所以make()方法会映射到f()。这里涉及到我们的老朋友this关键字，以及前面的方法的动态绑定。
        X x = new X();
        Transform tr =x::f();//通过[2]
    }
}

截止目前，我们已经知道了与接口方法同名的方法引用。 在 **[1]**，我们尝试把 `X` 的 `f()` 方法引用赋值给 **MakeString**。结果：即使 `make()` 与 `f()` 具有相同的签名，编译也会报“invalid method reference”（无效方法引用）错误。 这是因为实际上还有另一个隐藏的参数：我们的老朋友 `this`。 你不能在没有 `X` 对象的前提下调用 `f()`。 因此，`X :: f` 表示未绑定的方法引用，因为它尚未“绑定”到对象。

要解决这个问题，我们需要一个 `X` 对象，所以我们的接口实际上需要一个额外的参数的接口，如上例中的 **TransformX**。 如果将 `X :: f` 赋值给 **TransformX**，这在 Java 中是允许的。这次我们需要调整下心里预期——使用未绑定的引用时，函数方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 理由是：你需要一个对象来调用方法。

**[2]** 的结果有点像脑筋急转弯。 我接受未绑定的引用并对其调用 `transform()`，将其传递给 `X`，并以某种方式导致对 `x.f()` 的调用。 Java 知道它必须采用第一个参数，这实际上就是 `this`，并在其上调用方法。
```



```java
class This {
  void two(int i, double d) {}
  void three(int i, double d, String s) {}
  void four(int i, double d, String s, char c) {}
}

interface TwoArgs {
  void call2(This athis, int i, double d);
}

interface ThreeArgs {
  void call3(This athis, int i, double d, String s);
}

interface FourArgs {
  void call4(
    This athis, int i, double d, String s, char c);
}

public class MultiUnbound {
  public static void main(String[] args) {
    TwoArgs twoargs = This::two;
    ThreeArgs threeargs = This::three;
    FourArgs fourargs = This::four;
    This athis = new This();
    twoargs.call2(athis, 11, 3.14);
    threeargs.call3(athis, 11, 3.14, "Three");
    fourargs.call4(athis, 11, 3.14, "Four", 'Z');
  }
}
```



为了说明这一点，我将类命名为 **This** ，函数方法的第一个参数则是 **athis**，但是你应该选择其他名称以防止生产代码混淆。



**构造函数的引用**

CtorReference.java



**函数式接口**

>方法引用和 Lambda 表达式必须被赋值，同时编译器需要识别类型信息以确保类型正确。 Lambda 表达式特别引入了新的要求。
>
>Lambda表达式再研究，lambda表达式类似于匿名内部类，与内部类不同的是，lambda不会被java编译器编译成class文件，class文件需要导入，翻译，这样就存在性能问题。但是，lambda表达式会产生一个静态方法，该静态方法会与接口方法的签名(参数和返回值)绑定，通过invoke dynamic 去调用接口中的方法。通过lambda表达式采用的方法是运行时编译，编译后会生成class文件，显式的继承抽象类或者方法。
>
>```java
>import java.lang.invoke.LambdaForm.Hidden;
>
>// $FF: synthetic class
>final class Strategize$$Lambda$1 implements Strategy {
>private Strategize$$Lambda$1() {
>}
>
>@Hidden
>public String approach(String var1) {
>   return Strategize.lambda$main$0(var1);
>}
>     
>    
>}//lambda第二次编译后的代码 产生一个新的类，调用一次产生的static方法
> private static String lambda$main$0(String var0) {
>      return var0.toUpperCase();
>   }
>```
>
>
>
>方法引用再研究：
>放法引用同lambda表达式相似，都是在第二次编译java/lang/invoke/LambdaMetafactory.metafactory 产生一个class文件。但是方法引用不会产生这个静态方法，这个过程中我们又不得不谈谈面向对象中的static 和this这两个关键字，如果为绑定的静态方法，那么我们知道直接使用类名就可以调用该方法，因为该方法在编译期间就被绑定，不同的的非绑定的方法，那么就要使用对象实例来调用该方法(this隐式)，所以又再次产生了与lambda表达式不同的效果，即方法引用与接口或抽象类的方法的签名不必完全一致，如果非静态方法有一个对象的引用作为方法的参数传入，那么这个引用会被当作私有成员变量，那么我们的老朋友this，就会在其上调用该方法。从接口的方法映射到方法引用，或者lambda。

```java
final class Strategize$$Lambda$1 implements Strategy {
    private Strategize$$Lambda$1() {
    }

    @Hidden
    public String approach(String var1) {
        return Unrelated.twice(var1);
    }
}

// for Strategize$$Lambda$2
package com.langdon.java.onjava8.functional.test4;

import java.lang.invoke.LambdaForm.Hidden;

// $FF: synthetic class
final class Strategize$$Lambda$2 implements StrategyDev {
    private final Unrelated arg$1;

    private Strategize$$Lambda$2(Unrelated var1) {
        this.arg$1 = var1;
    }

    private static StrategyDev get$Lambda(Unrelated var0) {
        return new Strategize$$Lambda$2(var0);
    }

    @Hidden
    public String approach(String var1) {
        return this.arg$1.third(var1);
    }
}//构造函数本质上就是一个static函数 ，我们也可解释得清楚
```

现在重新回到函数式接口的问题上：

x->x.toString(); x为string类型

Lambda 表达式包含类型推导（编译器会自动推导出类型信息，避免了程序员显式地声明）。编译器必须能够以某种方式推导出 `x` 的类型。

>(x, y) -> x + y
>
>现在 `x` 和 `y` 可以是任何支持 `+` 运算符连接的数据类型，可以是两个不同的数值类型或者是 1 个 **String** 加任意一种可自动转换为 **String** 的数据类型（这包括了大多数类型）。 但是，当 Lambda 表达式被赋值时，编译器必须确定 `x` 和 `y` 的确切类型以生成正确的代码。
>
>该问题也适用于方法引用。 假设你要传递 `System.out :: println` 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？Java 8 引入了 `java.util.function` 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。
>
>```java
>@FunctionalInterface
>interface Functional {
>  String goodbye(String arg);
>}
>
>interface FunctionalNoAnn {
>  String goodbye(String arg);
>}
>
>/*
>@FunctionalInterface
>interface NotFunctional {
>  String goodbye(String arg);
>  String hello(String arg);
>}
>产生错误信息:
>NotFunctional is not a functional interface
>multiple non-overriding abstract methods
>found in interface NotFunctional
>*/
>
>public class FunctionalAnnotation {
>  public String goodbye(String arg) {
>    return "Goodbye, " + arg;
>  }
>  public static void main(String[] args) {
>    FunctionalAnnotation fa =
>      new FunctionalAnnotation();
>    Functional f = fa::goodbye;
>    FunctionalNoAnn fna = fa::goodbye;
>    // Functional fac = fa; // Incompatible
>    Functional fl = a -> "Goodbye, " + a;
>    FunctionalNoAnn fnal = a -> "Goodbye, " + a;
>  }
>}
>/*
>`@FunctionalInterface` 注解是可选的; Java 在 `main()` 中把 **Functional** 和 **FunctionalNoAnn** 都当作函数式接口。 `@FunctionalInterface` 的值在 `NotFunctional` 的定义中可见：接口中如果有多个方法则会产生编译时错误消息。
>仔细观察在定义 `f` 和 `fna` 时发生了什么。 `Functional` 和 `FunctionalNoAnn` 定义接口，然而被赋值的只是方法 `goodbye()`。
>首先这只是一个方法，而不是一个类；甚至，他都不是实现了该接口的类中的方法，java8在此添加一些小的魔法：如果将方法的引用或者lambda表达式赋值个函数式接口（类型需要匹配），java会适配你的赋值到目标的接口，编译器会自动包装方法引用或lambda表达式到实现接口类的实例。
>尽管 `FunctionalAnnotation` 确实适合 `Functional` 模型，但 Java 不允许我们将 `FunctionalAnnotation` 像 `fac` 定义一样直接赋值给 `Functional`，因为它没有明确地实现 `Functional` 接口。 令人惊奇的是 ，Java 8 允许我们以简便的语法为接口赋值函数。
>
>https://www.cnblogs.com/chenjingquan/p/10574320.html#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8
>
>*/
>```



以下是基本命名准则：

1. 如果只处理对象而非基本类型，名称则为 `Function`，`Consumer`，`Predicate` 等。参数类型通过泛型添加。
2. 如果接收的参数是基本类型，则由名称的第一部分表示，如 `LongConsumer`，`DoubleFunction`，`IntPredicate` 等，但基本 `Supplier` 类型例外。
3. 如果返回值为基本类型，则用 `To` 表示，如 `ToLongFunction <T>` 和 `IntToLongFunction`。
4. 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 `UnaryOperator`，两个参数使用 `BinaryOperator`。
5. 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。
6. 如果接收的两个参数类型不同，则名称中有一个 `Bi`。

| **特征**                                            |                       **函数式方法名**                       |                           **示例**                           |
| :-------------------------------------------------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 无参数； <br> 无返回值                              |         **Runnable** <br> (java.lang)  <br>  `run()`         |                         **Runnable**                         |
| 无参数； <br> 返回类型任意                          |         **Supplier** <br> `get()` <br> `getAs类型()`         | **Supplier`<T>`  <br> BooleanSupplier  <br> IntSupplier  <br> LongSupplier  <br> DoubleSupplier** |
| 无参数； <br> 返回类型任意                          |   **Callable** <br> (java.util.concurrent)  <br> `call()`    |                      **Callable`<V>`**                       |
| 1 参数； <br> 无返回值                              |                 **Consumer** <br> `accept()`                 | **`Consumer<T>` <br> IntConsumer <br> LongConsumer <br> DoubleConsumer** |
| 2 参数 **Consumer**                                 |                **BiConsumer** <br> `accept()`                |                    **`BiConsumer<T,U>`**                     |
| 2 参数 **Consumer**； <br> 1 引用； <br> 1 基本类型 |             **Obj类型Consumer** <br> `accept()`              | **`ObjIntConsumer<T>` <br> `ObjLongConsumer<T>` <br> `ObjDoubleConsumer<T>`** |
| 1 参数； <br> 返回类型不同                          | **Function** <br> `apply()` <br> **To类型** 和 **类型To类型** <br> `applyAs类型()` | **Function`<T,R>` <br> IntFunction`<R>` <br> `LongFunction<R>` <br> DoubleFunction`<R>` <br> ToIntFunction`<T>` <br> `ToLongFunction<T>` <br> `ToDoubleFunction<T>` <br> IntToLongFunction <br> IntToDoubleFunction <br> LongToIntFunction <br> LongToDoubleFunction <br> DoubleToIntFunction <br> DoubleToLongFunction** |
| 1 参数； <br> 返回类型相同                          |               **UnaryOperator** <br> `apply()`               | **`UnaryOperator<T>` <br> IntUnaryOperator <br> LongUnaryOperator <br> DoubleUnaryOperator** |
| 2 参数类型相同； <br> 返回类型相同                  |              **BinaryOperator** <br> `apply()`               | **`BinaryOperator<T>` <br> IntBinaryOperator <br> LongBinaryOperator <br> DoubleBinaryOperator** |
| 2 参数类型相同; <br> 返回整型                       |         Comparator <br> (java.util) <br> `compare()`         |                     **`Comparator<T>`**                      |
| 2 参数； <br> 返回布尔型                            |                 **Predicate** <br> `test()`                  | **`Predicate<T>` <br> `BiPredicate<T,U>` <br> IntPredicate <br> LongPredicate <br> DoublePredicate** |
| 参数基本类型； <br> 返回基本类型                    |         **类型To类型Function** <br> `applyAs类型()`          | **IntToLongFunction <br> IntToDoubleFunction <br> LongToIntFunction <br> LongToDoubleFunction <br> DoubleToIntFunction <br> DoubleToLongFunction** |
| 2 参数类型不同                                      |                 **Bi操作** <br> (不同方法名)                 | **`BiFunction<T,U,R>` <br> `BiConsumer<T,U>` <br> `BiPredicate<T,U>` <br> `ToIntBiFunction<T,U>` <br> `ToLongBiFunction<T,U>` <br> `ToDoubleBiFunction<T>`** |



```java

import java.util.*;
import java.util.function.*;

class AA {}
class BB {}
class CC {}
public class ClassFunctionals {
  static AA f1() { return new AA(); }
  static int f2(AA aa1, AA aa2) { return 1; }
  static void f3(AA aa) {}
  static void f4(AA aa, BB bb) {}
  static CC f5(AA aa) { return new CC(); }
  static CC f6(AA aa, BB bb) { return new CC(); }
  static boolean f7(AA aa) { return true; }
  static boolean f8(AA aa, BB bb) { return true; }
  static AA f9(AA aa) { return new AA(); }
  static AA f10(AA aa1, AA aa2) { return new AA(); }
    public static void main(String[] args) {
    Supplier<AA> s = ClassFunctionals::f1;
    s.get();
    Comparator<AA> c = ClassFunctionals::f2;
    c.compare(new AA(), new AA());
    Consumer<AA> cons = ClassFunctionals::f3;
    cons.accept(new AA());
    BiConsumer<AA,BB> bicons = ClassFunctionals::f4;
    bicons.accept(new AA(), new BB());
    Function<AA,CC> f = ClassFunctionals::f5;
    CC cc = f.apply(new AA());
    BiFunction<AA,BB,CC> bif = ClassFunctionals::f6;
    cc = bif.apply(new AA(), new BB());
    Predicate<AA> p = ClassFunctionals::f7;
    boolean result = p.test(new AA());
    BiPredicate<AA,BB> bip = ClassFunctionals::f8;
    result = bip.test(new AA(), new BB());
    UnaryOperator<AA> uo = ClassFunctionals::f9;
    AA aa = uo.apply(new AA());
    BinaryOperator<AA> bo = ClassFunctionals::f10;
    aa = bo.apply(new AA(), new AA());
  }
}
//请**注意**，每个方法名称都是随意的（如 `f1()`，`f2()`等）。正如你刚才看到的，一旦将方法引用赋值给函数接口，我们就可以调用与该接口关联的函数方法。 在此示例中为 `get()`、`compare()`、`accept()`、`apply()` 和 `test()`。
```

**高阶函数**

[高阶函数](https://en.wikipedia.org/wiki/Higher-order_function)（Higher-order Function）只是一个消费或产生函数的函数。

>生产函数：使用lambda表达式返回一个函数。lambda表达式就是产生一个匿名内部类
>
>消费函数：import java.util.function.*;
>
>class One {}
>class Two {}
>
>public class ConsumeFunction {
>  static Two consume(Function<One,Two> onetwo) {
>    return onetwo.apply(new One());
>  }
>  public static void main(String[] args) {
>    Two two = consume(one -> new Two());
>  }
>}

```java
//消费函数产生函数
  import java.util.function.*;

class I {
  @Override
  public String toString() { return "I"; }
}//class I

class O {
  @Override
  public String toString() { return "O"; }
}//class O
//Function<T,R>
public class TransformFunction {
  static Function<I,O> transform(Function<I,O> in) {
    return in.andThen(o -> {
      System.out.println(o);
      return o;//lambda表达式，生成静态方法，并实现接口，接口方法映射->静态方法 打印 参数 o 返回参数 o
    });//消费函数  返回接口 
      //andThen 的参数为接口
      //return (T t) -> after.apply(apply(t));
      //R apply(T t);
  }
  public static void main(String[] args) {
    Function<I,O> f2 = transform(i -> {
      System.out.println(i);
      return new O();
    });
    O o = f2.apply(new I());
  }
}  
```

**闭包**

>**闭包**（Closure）一词总结了这些问题。 它非常重要，利用闭包可以轻松生成函数。当你调用函数时，它对那些 “外部 ”变量引用了什么?  如果语言不能自动解决这个问题，那将变得非常具有挑战性。能够解决这个问题的语言被称为**支持闭包**，或者叫作在词法上限定范围( 也使用术语*变量捕获* )。Java 8 提供了有限但合理的闭包支持，我们将用一些简单的例子来研究它。
>
>

```java
import java.util.function.*;

public class Closure1 {
  int i;
  IntSupplier makeFun(int x) {
    return () -> x + i++;
  }
}

```



==========================================================================================

# 流式编程



>集合优化了对象的存储，而流和对象的处理有关。

流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说。利用流，我们无需迭代集合中的元素，就可以提取和操作它们。这些管道通常被组合在一起，在流上形成一条操作管道。流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体。流使得 Java 8 更具吸引力。



>声明式：声明要做什么，而非怎么做的编程风格。正如我们在函数式编程中所看到的。
>另一个重要方面，流是懒加载的。这代表着它只在绝对必要时才计算。命令式编程：显式地编写迭代机制称为外部迭代。而在 `Randoms.java` 中，流式编程采用内部迭代，这是流式编程的核心特性之一。这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。

#### Stream的中间操作

如果Stream只有中间操作是不会执行的，当执行终端操作的时候才会执行中间操作，这种方式称为延迟加载或惰性求值。多个中间操作组成一个中间操作链，只有当执行终端操作的时候才会执行一遍中间操作链，具体是因为什么我们在后面再说明。下面看下Stream有哪些中间操作。

![img](https://upload-images.jianshu.io/upload_images/1117220-24c366c986cc953f.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

**流支持**





# 异常

>改进的错误恢复机制是提高代码健壮性的最强有力的方式。错误恢复在我们所编写的每一个程序中都是基本的要素，但是在 Java 中它显得格外重要，因为 Java 的主要目标之一就是创建供他人使用的程序构件。编译期间不能找到所有的代码，必须在运行期间处理，异常处理就显得十分有必要！
>
>

异常的概念：

>C 以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而并不属于语言的一部分。通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或标志进行检查，以判定是否发生了错误。然而，随着时间的推移，人们发现，高傲的程序员们在使用程序库的时候更倾向于认为：“对，错误也许会发生，但那是别人造成的，不关我的事”。所以，程序员不去检查错误情形也就不足为奇了（何况对某些错误情形的检查确实很无聊）。如果的确在每次调用方法的时候都彻底地进行错误检查，代码很可能会变得难以阅读。正是由于程序员还仍然用这些方式拼凑系统，所以他们拒绝承认这样一个事实：对于构造大型、健壮、可维护的程序而言，这种错误处理模式已经成为了主要障碍。Java 中的异常处理机制则建立在 C++ 的基础之上（尽管看上去更像 Object Pascal）。异常往往能降低错误处理代码的复杂度。如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它。而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误。理想情况下，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节省代码，而且把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。

异常的意义：不允许程序沿着其正常的路径继续走下去，并告诉我们程序发生了什么问题。

基本异常

>异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题。把异常情形与普通问题相区分很重要，所谓的普通问题是指，在当前环境下能得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续下去了，因为在当前环境下无法获得必要的信息来解决问题。你所能做的就是从当前环境跳出，并且把问题提交给上一级环境。这就是抛出异常时所发生的事情。

当抛出异常后有几件事情会发生：

1. 使用new 在堆上创建异常的对象
2. 当执行路径被终止的时候，从当前的环境弹出对异常对象的引用。
3. 异常处理机制接管程序，并寻找一个恰当的地方来执行程序，这个恰当的地方就是一场处理程序，它的任务就是将程序从错误中恢复

```java
if(obj=null){
	throw new NullPointerExcption();
}
//这就是一个抛出一个异常，从当前环境被抛出到大环境，在当前环境就不用为此担心

/*异常使得我们可以将每件事都当作一个事务来考虑，而异常可以看护着这些事务的底线“…事务的基本保障是我们所需的在分布式计算中的异常处理。事务是计算机中的合同法，如果出了什么问题，我们只需要放弃整个计算。”我们还可以将异常看作是一种内建的恢复（undo）系统，因为（在细心使用的情况下）我们在程序中可以拥有各种不同的恢复点。如果程序的某部分失败了，异常将“恢复”到程序中某个已知的稳定点上。
*/
```



异常参数

>我们总是用 new 在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常类都有两个构造器：一个是无参构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：
>
>throw new Exception();
>
>在使用 **new** 创建了异常对象之后，此对象的引用将传给 **throw**。尽管异常对象的类型通常与方法设计的返回类型不同，但从效果上看，它就像是从方法“返回”的.另外还能用抛出异常的方式从当前的作用域退出。在这两种情况下，将会返回一个异常对象，然后退出方法或作用域。
>
>throw 和return 的不同之处在于它们的返回地点不同，异常会在一个恰当的异常处理程序中得到解决。能够抛出任意类型的 **Throwable** 对象，它是异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象内部或者用异常类的名称来暗示。上一层环境通过这些信息来决定如何处理异常。（通常，唯一的信息只有异常的类型名，而在异常对象内部没有任何有意义的信息。）
>
>异常继承关系：
>
>![img](https://upload-images.jianshu.io/upload_images/2399767-5220fb338462ad08?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp)



捕获异常：

>try块：
>要是在抛出异常后，执行一般都会终止，如果不希望当前路线执行终止就可以使用try块来捕获异常
>
>```java
>try{
>	statement；
>}
>/*异常处理程序
>catch块 ，紧跟在try后
>当异常被抛出的时候，异常处理机制将负责搜寻与异常类型相匹配的第一个处理器程序，然后进入catch块处理异常
>许多不同的方法调用可能会产生类型相同的异常，我们只需要提供一个针对类型的处理器
>*/
>try{
>    
>}catch(type){
>    
>}
>
>```
>
>终止与恢复：
>
>一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。另外一种就是恢复模型，意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，通常希望异常被处理之后能继续执行程序。如果想要用 Java 实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。使用while循环 执行try块
>
>

自定义异常

不必拘泥于 Java 中已有的异常类型。Java 提供的异常体系不可能预见所有的希望加以报告的错误，所以可以自己定义异常类来表示程序中可能会遇到的特定问题。

要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生无参构造器。

```java
public MyException extends Exception{
    super();
}
/**
使用 super 关键宇明确调用了其基类构造器，它接受一个字符串作为参数。

/


```

异常与记录日志

> java.util.logging 工具将输出记录到日志中
>
>```java
>public class LoggingException extends Exception{
>    private static Logger logger =
>            Logger.getLogger("LoggingException");
>    public LoggingExecption() {
>		// TODO Auto-generated constructor stub
>		StringWriter stringWriter = new StringWriter();
>		printStackTrace(new PrintWriter(stringWriter));
>		logger.severe(stringWriter.toString());
>	public static void main(String[] args) {
>		try {
>			throw new LoginException();
>		} catch (LoginException e) {
>			// TODO: handle exception
>			System.err.print(e);
>		}
>		try {
>			throw new LoginException();
>		} catch (LoginException e) {
>			// TODO: handle exception
>			System.err.println("Caught " + e);
>		}
>	}
>}
>```
>
>
>
>

声明异常：

异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表

```java
void f() throws exception{}
/*
代码必须与声明的异常保持一致，如果方法里的异常没有进行处理，编译器就会发现这个问题并提醒你。
可以声明方法将抛出异常，实际上却不抛出。编译器相信了这个声明，并强制此方法的用户像真的抛出异常那样使用这个方法。这样做的好处是，为异常先占个位子，以后就可以抛出这种异常而不用修改已有的代码。在定义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。

这种在编译时被强制检查的异常称为被检查的异常。


*/
```



捕获所有异常

>可以只写一个异常处理程序来捕获所有类型的异常。通过捕获异常类型的基类 Exception，就可以做到这一点
>
>```java
>/*
>多重捕获异常：
>使用多个catch块语句，这里存在一个问题，捕获异常类型的问题，它涉及到栈的轨迹。 见Demo01.java
>
>printStackTrace() 方法所提供的信息可以通过 getStackTrace() 方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一桢。
>
>关于StackTraceElement的使用
>getStackTrace() 可以获取一个栈轨迹中的元素构成的数组。从而遍历就可获取栈元素的具体信息 例如方法名，类名
>通过改类我们就可以知道调用函数时的调用轨迹，以及异常捕获的轨迹。
>
>函数与栈：https://blog.csdn.net/qq_36503007/article/details/82887811?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
>
>函数调用过程中会被逆序压入栈中，且参数也会被逆序压入栈中，作为参数的变量，它们的值并没有发生改变。其原因就在于它们本身并没有参与被调用函数中的运算，真正参与运算的是它们在栈中的拷贝。
>*/
>```
>
>重新抛出异常
>有时希望把刚捕获的异常重新抛出，尤其是在使用 Exception 捕获所有异常的时候。既然已经得到了对当前异常对象的引用，可以直接把它重新抛出：
>
>catch(Exception e) {
>    System.out.println("An exception was thrown");
>    throw e;
>}
>
>重抛异常会把异常抛给上一级环境中的异常处理程序，同一个 try 块的后续 catch 子句将被忽略。
>
>如果只是把当前异常对象重新抛出，那么 printStackTrace() 方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用 filInStackTrace() 方法，这将返回一个 Throwable 对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的
>
>filInStackTrace() 是一个native方法 ，可以获取底层的堆栈信息
>
>有可能在捕获异常之后抛出另一种异常。这么做的话，得到的效果类似于使用 filInStackTrace() 

**精准的重新抛出异常**

>在 Java 7 之前，如果遇到异常，则只能重新抛出该类型的异常。这导致在 Java 7 中修复的代码不精确。所以在 Java 7 之前，这无法编译：
>
>```java
>class BaseException extends Exception {}
>class DerivedException extends BaseException {}
>
>public class PreciseRethrow {
>    void catcher() throws DerivedException {
>        try {
>            throw new DerivedException();
>        } catch(BaseException e) {
>            throw e;
>        }
>    }
>}
>//这是一个很小但很有用的修复
>```

**异常链**

定义:常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。

现在所有 Throwable 的子类在构造器中都可以接受一个 cause（因由）对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。现在所有 Throwable 的子类在构造器中都可以接受一个 cause（因由）对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置

，在 Throwable 的子类中，只有三种基本的异常类提供了带 cause 参数的构造器。它们是 Error（用于 Java 虚拟机报告系统错误）、Exception 以及 RuntimeException。如果要把其他类型的异常链接起来，应该使用 initCause0 方法而不是构造器。



**JAVA标准异常**

- error
- Runtime

error是jvm或系统异常，我们不用关心

RuntimeException 代表的是编程错误：

1. 无法预料的错误。比如从你控制范围之外传递进来的 null 引用。
2. 作为程序员，应该在代码中进行检查的错误。（比如对于 ArrayIndexOutOfBoundsException，就得注意一下数组的大小了。）在一个地方发生的异常，常常会在另一个地方导致错误。

>**finally清理**
>
>有一些代码片段，可能会希望无论 try 块中的异常是否抛出，它们都能得到执行。这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成），为了达到这个效果，可以在异常处理程序后面加上 finally 子句。
>
>```java
>try{
>
>}catch(Execption e){
>
>}finally{
>
>}
>/**finally用来做什么？对于没有垃圾回收和折构函数自动调用机制的语言来说，finally十分重要。，它能保证程序try中无论发生什么情况，finally都能被执行。
>Demo03.java
>
>return 也可以配合finally使用
>/
>```
>

**异常丢失**

异常在某些特殊的finally子句中可能会被轻易忽略。
即一个函数有声明异常，却在finally语句中调用，这就成了一个缺陷，该异常还未处理就抛出了一个异常



**异常限制**

当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。这个限制很有用，因为这意味着，若当基类使用的代码应用到其派生类对象的时候，一样能够工作（当然，这是面向对象的基本概念），异常也不例外。

StormyInning.java

>异常对构造器不起作用，可以看看storminning构造器可以声明抛出任何异常，应为子类或调用父类的构造器来确保成员的初始化，所以派生类的构造器的异常说明必须包括子类的异常说明。
>
>派生类构造器不能捕获基类构造器抛出的异常。
>
>walk方法没有声明异常，页面try处理异常，当抛出异常时就会报错。
>Demo04.java 则说明了，如果基类什么抛出异常，子类的方法可以不抛出异常，假使基类的方法会抛出异常，这样做也不会破坏已有的程序，所以也没有问题。如果子类抛出异常的范围大于基类的异常，编译就会强制要求父类抛出异常。方法重写的时候，如果父类没有抛出任何异常，那么子类只可以抛出运行时异常，不可以抛出编译时异常。
>
>继承与异常的关系，在继承中子类隐性的拥有父类的一切，子类是”大于“基类，而异常的关系则相反。

**构造器**

有一点很重要，即你要时刻询问自己“如果异常发生了，所有东西能被正确的清理吗？"尽管大多数情况下是非常安全的，但涉及构造器时，问题就出现了。构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。如果在构造器内抛出了异常，这些清理行为也许就不能正常工作了。这意味着在编写构造器时要格外细心。

>构造器的初始化确保对象数据的完整性，在构造函数中使用finally就会有一个麻烦，finally会在构造器执行之后执行清理，这样对象的声明周期都不会处于持久的状态。
>
>对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的 try 子句
>
>



**Try-With-Resources 用法**

文件的打开，读取和关闭都发生在构造函数中。或者，如果读取和存储文件不切实际，你可以改为生成 Stream。

```java
import java.io.*;
import java.nio.file.*;
import java.util.stream.*;
public class InputFile2 {
    private String fname;

    public InputFile2(String fname) {
        this.fname = fname;
    }

    public Stream<String> getLines() throws IOException {
        return Files.lines(Paths.get(fname));
    }

    public static void
    main(String[] args) throws IOException {
        new InputFile2("InputFile2.java").getLines()
                .skip(15)
                .limit(1)
                .forEach(System.out::println);
    }
}
```

当需要清理资源的时候，需要在特定时刻清理资源的时刻，比如离开作用域的时候。

```java
import java.io.*;
public class MessyExceptions {
    public static void main(String[] args) {
        InputStream in = null;
        try {
            in = new FileInputStream(
                    new File("MessyExceptions.java"));
            int contents = in.read();
            // Process contents
        } catch(IOException e) {
            // Handle the error
        } finally {
            if(in != null) {
                try {
                    in.close();
                } catch(IOException e) {
                    // Handle the close() error
                }
            }
        }
    }
}

//但是在finally语句中使用try块，事情感觉变得复杂。java7中使用了try-with-resource
import java.io.*;
public class TryWithResources {
    public static void main(String[] args) {
        try(
                InputStream in = new FileInputStream(
                        new File("TryWithResources.java"))
            //括号内的部分称为资源规范头,可以用于整个try块
        ) {
            int contents = in.read();
            // Process contents
        } catch(IOException e) {
            // Handle the error
            //更重要的是，无论你如何退出 try 块（正常或异常），都会执行前一个 finally 子句的等价物，但不会编写那些杂乱而棘手的代码。是如何工作的？在 try-with-resources 定义子句中创建的对象（在括号内）必须实现 java.lang.AutoCloseable 接口，这个接口有一个方法：close()。当在 Java 7  中引入 AutoCloseable 时，许多接口和类被修改以实现它；查看 Javadocs 中的 AutoCloseable，可以找到所有实现该接口的类列表，其中包括 Stream 对象
        }
    }
}
```

为揭示细节，我们将创建一个继承autocloseable类

AutoCloseableDetails.java java8不支持，编译器报错



**匹配异常**

>抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。因此，就会报错
>



**异常处理的意义**

异常处理的意义在于将错误的代码分离，让程序员专注于一段代码，这样代码也更容易理解和维护，如果刻意的强制你在可能还没准备好处理错误的时候被迫加上 catch 子句，这可能就会导致吞食则有害的问题。虽然这样可以编译通过，但异常就会丢失，所以这种看起来最简单的方法，却可能是最糟糕的做法。



**Execption底层原理

>## printStackTrace
>
>栈轨迹中的元素 **StackTraceElement**
>
>本地方法native getStackTrace  获取堆栈的Element元素数组，从而获取堆栈的具体信息
>
> public void printStackTrace() {
>        printStackTrace(System.err);
>    }
>
>printStackTrace  标准错误输出到控制台
>
>

===========================================================================================

 # 文件与IO

在了解IO体系之前，我们先来了解一下装饰器设计模式，再进入Java IO 我们就能更加深刻理解IO体系。

装饰器设计模式

>**Component：组件对象的接口**，可以给这些对象动态的添加职责。
>
>**ConcreteComponent：具体的组件对象**，实现组件对象接口，通常就是被装饰器装饰的原始对象，也就是可以给这个对象添加职责。
>
>**Decorator：所有装饰器的抽象父类**，需要定义一个与组件接口一致的接口，并持有一个Component对象，其实就是持有一个被装饰的对象。注意，这个被装饰的对象不一定是最原始的那个对象了，也可能是被其它装饰器装饰过后的对象，反正都是实现的同一个接口，也就是同一类型。
>
>**ConcreteDecorator：实际的装饰器对象**，实现具体要向被装饰对象添加的功能。
>
>
>
>![img](https://upload-images.jianshu.io/upload_images/2062729-bc3b4bbb5d6b40c1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1192/format/webp)



**文件和目录路径**

一个 **Path** 对象表示一个文件或者目录的路径，是一个跨操作系统（OS）和文件系统的抽象，目的是在构造路径时不必关注底层操作系统，代码可以在不进行修改的情况下运行在不同的操作系统上。**java.nio.file.Paths** 类包含一个重载方法 **static get()**，该方法接受一系列 **String** 字符串或一个*统一资源标识符*(URI)作为参数，并且进行转换返回一个 **Path** 对象：

选取路径部分片段：

```java
package 文件;

import java.nio.file.Path;
import java.nio.file.Paths;

public class PartsOfPaths {
    public static void main(String[] args) {
        System.out.println(System.getProperty("os.name"));
        Path path = Paths.get("PartsofPaths.java").toAbsolutePath();
        for(int i=0;i<path.getNameCount();i++){
            System.out.println(path.getName(i));
        }
    }
}
```



**Paths**的增减修改
我们必须能通过对 **Path** 对象增加或者删除一部分来构造一个新的 **Path** 对象。我们使用 **relativize()** 移除 **Path** 的根路径，使用 **resolve()** 添加 **Path** 的尾路径(不一定是“可发现”的名称)。



# 注解

定义注解：注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件。

**元注解**

Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注解其他的注解

| 注解        | 解释                                                         |
| ----------- | ------------------------------------------------------------ |
| @Target     | 表示注解可以用于哪些地方。可能的 **ElementType** 参数包括：<br/>**CONSTRUCTOR**：构造器的声明<br/>**FIELD**：字段声明（包括 enum 实例）<br/>**LOCAL_VARIABLE**：局部变量声明<br/>**METHOD**：方法声明<br/>**PACKAGE**：包声明<br/>**PARAMETER**：参数声明<br/>**TYPE**：类、接口（包括注解类型）或者 enum 声明 |
| @Retention  | 表示注解信息保存的时长。可选的 **RetentionPolicy** 参数包括：<br/>**SOURCE**：注解将被编译器丢弃<br/>**CLASS**：注解在 class 文件中可用，但是会被 VM 丢弃。<br/>**RUNTIME**：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。 |
| @Documented | 将此注解保存在 Javadoc 中                                    |
| @Inherited  | 允许子类继承父类的注解                                       |
| @Repeatable | 允许一个注解可以被使用一次或者多次（Java 8）。               |



**注解处理器**

如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。



**注解元素**

- 所有基本类型（int、float、boolean等）
- String
- Class
- enum
- Annotation
- 以上类型的数组

也不允许使用任何包装类型，但是由于自动装箱的存在，这不算是什么限制。注解也可以作为元素的类型。稍后你会看到，注解嵌套是一个非常有用的技巧。另外还可以使用default 限制



生成外部文件

当有些框架需要一些额外的信息才能与你的源代码协同工作，这种情况下注解就会变得十分有用。像 Enterprise JavaBeans (EJB3 之前)这样的技术，每一个 Bean 都需要需要大量的接口和部署描述文件，而这些就是“样板”文件。Web Service，自定义标签库以及对象/关系映射工具（例如 Spring和 Hibernate）通常都需要 XML 描述文件，而这些文件脱离于代码之外。除了定义 Java 类，程序员还必须忍受沉闷，重复的提供某些信息，例如类名和包名等已经在原始类中已经提供的信息。每当你使用外部描述文件时，他就拥有了一个类的两个独立信息源，这经常导致代码的同步问题。同时这也要求了为项目工作的程序员在知道如何编写 Java 程序的同时，也必须知道如何编辑描述文件。

**注解不支持继承，但可以使用嵌套注解**



### 使用javac处理注解

通过 **javac**，你可以通过创建编译时（compile-time）注解处理器在 Java 源文件上使用注解，而不是编译之后的 class 文件。但是这里有一个重大限制：你不能通过处理器来改变源代码。唯一影响输出的方式就是创建新的文件。如果你的注解处理器创建了新的源文件，在新一轮处理中注解会检查源文件本身。工具在检测一轮之后持续循环，直到不再有新的源文件产生。然后它编译所有的源文件。

```java
package annotations.simplest;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
@Retention(RetentionPolicy.SOURCE)
@Target({ElementType.TYPE, ElementType.METHOD,
        ElementType.CONSTRUCTOR,
        ElementType.ANNOTATION_TYPE,
        ElementType.PACKAGE, ElementType.FIELD,
        ElementType.LOCAL_VARIABLE})
public @interface Simple {
    String value() default "-default-";
}
```

**@Retention** 的参数现在为 **SOURCE**，这意味着注解不会再存留在编译后的代码。这在编译时处理注解是没有必要的，它只是指出，在这里，**javac** 是唯一有机会处理注解的代理。

# 反射

>```j&#39;a&#39;va
>System.getProperty("sun.boot.library.path");//获取启动类加载器 路径
>```
>
>![image-20200329000829227](C:\Users\Ellen\AppData\Roaming\Typora\typora-user-images\image-20200329000829227.png)
>
>类加载的三种方式：
>
>- 命令行启动应用时候由JVM初始化加载
>- 通过`Class.forName()`方法动态加载
>- 通过`ClassLoader.loadClass()`方法动态加载
>
>##### Class.forName()和ClassLoader.loadClass()区别
>
>- `Class.forName()`：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
>- `ClassLoader.loadClass()`：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
>- `Class.forName(name, initialize, loader)`带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。
>
>#### JVM类加载机制
>
>- `全盘负责`，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
>- `父类委托`，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
>- `缓存机制`，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效
>
>双亲委派模型意义：
>
>- 系统类防止内存中出现多份同样的字节码
>- 保证Java程序安全稳定运行

